// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast::{Ast}
use lex for std::jule::lex
use strings for std::strings

struct Formatter {
    mut buf:    str
    mut f:      &Ast
    mut indent: str
}

impl Formatter {
    static fn new(): &Formatter {
        ret new(Formatter)
    }

    fn add_indent(&self) {
        self.indent += "    "
    }

    fn done_indent(&self) {
        self.indent = self.indent[:self.indent.len - 4]
    }

    fn format_expr(&self, &expr: &ast::Expr): str {
        let ef = ExprFormatter{
            fmt: self,
        }
        ef.format(expr.kind)
        ret ef.buf
    }

    fn format_type(&self, &expr: &ast::TypeDecl): str {
        let tf = TypeFormatter{
            fmt: self,
        }
        tf.format(expr.kind)
        ret tf.buf
    }

    fn directive(&self, &d: &ast::Directive) {
        self.buf += "#"
        self.buf += d.tag.kind
        for _, arg in d.args {
            self.buf += " "
            self.buf += arg.kind
        }
    }

    fn directives(&self, dvs: []&ast::Directive) {
        for _, d in dvs {
            self.buf += "\n"
            self.directive(d)
        }
    }

    fn use_decl(&self, d: &ast::UseDecl) {
        if d.cpp_linked {
            self.buf += "cpp "
        }
        self.buf += "use "
        if d.alias != "" {
            self.buf += d.alias
            self.buf += " for "
        }
        if d.cpp_linked {
            self.buf += "\""
            self.buf += d.link_path
            self.buf += "\""
        } else {
            self.buf += d.link_path
        }
        if d.full {
            self.buf += "::*"
            ret
        }
        if d.selected.len == 0 {
            ret
        }
        self.buf += "::{\n"
        for _, s in d.selected {
            self.buf += "    "
            self.buf += s.kind
            self.buf += ",\n"
        }
        self.buf += "}"
    }

    fn use_decls(&self) {
        if self.f.use_decls.len == 0 {
            ret
        }
        self.buf += "\n"
        for _, decl in self.f.use_decls {
            self.buf += "\n"
            self.use_decl(decl)
        }
    }

    fn generics(&self, &g: []&ast::GenericDecl) {
        if g.len == 0 {
            ret
        }
        self.buf += "["
        for i, t in g {
            self.buf += t.ident
            if i + 1 < g.len {
                self.buf += ","
            }
        }
        self.buf += "]"
    }

    fn fn_decl(&self, mut d: &ast::FnDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.buf += "\n"
        }
        if d.public {
            self.buf += "pub "
        }
        if d.statically {
            self.buf += "static "
        }
        self.buf += "fn "
        self.buf += d.ident
        self.generics(d.generics)
        self.buf += "("
        for i, p in d.params {
            if p.mutable {
                self.buf += "mut "
            }
            if p.reference {
                self.buf += "&"
            }
            if !lex::is_anon_ident(p.ident) {
                self.buf += p.ident
                self.buf += ": "
            } else if p.reference {
                self.buf += "_: "
            }
            self.buf += self.format_type(p.kind)
            if i + 1 < d.params.len {
                self.buf += ", "
            }
        }
        self.buf += ")"
    }

    fn var_decl(&self, mut d: &ast::VarDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.buf += "\n"
        }
        if d.cpp_linked {
            self.buf += "cpp let "
        } else {
            if d.public {
                self.buf += "pub "
            }
            if d.statically {
                self.buf += "static "
            }
            if d.constant {
                self.buf += "const "
            }
        }
        if d.mutable {
            self.buf += "mut "
        }
        if d.reference {
            self.buf += "&"
        }
        self.buf += d.ident
        if d.kind != nil {
            self.buf += ": "
            self.buf += self.format_type(d.kind)
        }
        if d.expr != nil {
            self.buf += " = "
            self.buf += self.format_expr(d.expr)
        }
    }

    fn node(&self, mut &node: ast::Node) {
        match type node.data {
        | &ast::EnumDecl:
            break
        | &ast::FnDecl:
            self.fn_decl((&ast::FnDecl)(node.data))
        | &ast::StructDecl:
            break
        | &ast::TraitDecl:
            break
        | &ast::TypeAliasDecl:
            break
        | &ast::VarDecl:
            self.var_decl((&ast::VarDecl)(node.data))
        | &ast::Impl:
            break
        }
    }

    fn nodes(&self) {
        for (_, mut node) in self.f.nodes {
            self.buf += "\n\n"
            self.node(node)
        }
    }

    fn format(&self, mut &f: &Ast): str {
        self.f = f
        self.directives(self.f.top_directives)
        self.use_decls()
        self.nodes()
        self.f = nil
        ret strings::trim(self.buf, " \n\r\v\t")
    }
}

struct TypeFormatter {
    mut fmt: &Formatter
    mut buf: str
}

impl TypeFormatter {
    fn generics(self, g: []&ast::TypeDecl) {
        if g.len == 0 {
            ret
        }
        self.buf += "["
        for i, t in g {
            self.format(t.kind)
            if i + 1 < g.len {
                self.buf += ","
            }
        }
        self.buf += "]"
    }

    fn ident(self, id: &ast::IdentTypeDecl) {
        if id.cpp_linked {
            self.buf += "cpp."
        }
        self.buf += id.ident
        self.generics(id.generics)
    }

    fn namespace(self, ns: &ast::NamespaceTypeDecl) {
        for _, id in ns.idents {
            self.buf += id.kind
            self.buf += "::"
        }
        self.ident(ns.kind)
    }

    fn sptr(self, sptr: &ast::SptrTypeDecl) {
        self.buf += "&"
        self.format(sptr.elem.kind)
    }

    fn slc(self, slc: &ast::SlcTypeDecl) {
        self.buf += "[]"
        self.format(slc.elem.kind)
    }

    fn ptr(self, ptr: &ast::PtrTypeDecl) {
        self.buf += "*"
        if ptr.is_unsafe() {
            self.buf += "unsafe"
            ret
        }
        self.format(ptr.elem.kind)
    }

    fn arr(self, arr: &ast::ArrTypeDecl) {
        self.buf += "["
        if arr.auto_sized() {
            self.buf += "..."
        } else {
            self.buf += self.fmt.format_expr(arr.size)
        }
        self.buf += "]"
        self.format(arr.elem.kind)
    }

    fn map(self, map: &ast::MapTypeDecl) {
        self.buf += "["
        self.format(map.key.kind)
        self.buf += ":"
        self.format(map.val.kind)
        self.buf += "]"
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::IdentTypeDecl:
            self.ident((&ast::IdentTypeDecl)(kind))
        | &ast::NamespaceTypeDecl:
            self.namespace((&ast::NamespaceTypeDecl)(kind))
        | &ast::SptrTypeDecl:
            self.sptr((&ast::SptrTypeDecl)(kind))
        | &ast::SlcTypeDecl:
            self.slc((&ast::SlcTypeDecl)(kind))
        | &ast::PtrTypeDecl:
            self.ptr((&ast::PtrTypeDecl)(kind))
        | &ast::ArrTypeDecl:
            self.arr((&ast::ArrTypeDecl)(kind))
        | &ast::MapTypeDecl:
            self.map((&ast::MapTypeDecl)(kind))
        }
    }
}

struct ExprFormatter {
    mut fmt: &Formatter
    mut buf: str
}

impl ExprFormatter {
    fn usexpr(self, u: &ast::UseExpr) {
        self.buf += "use "
        self.format(u.expr.kind)
    }

    fn tuple(self, tup: &ast::TupleExpr) {
        for i, expr in tup.expr {
            self.format(expr.kind)
            if i + 1 < tup.expr.len {
                self.buf += ", "
            }
        }
    }

    fn lit(self, l: &ast::LitExpr) {
        self.buf += l.value
    }

    fn unsafexpr(self, u: &ast::UnsafeExpr) {
        self.buf += "unsafe { "
        self.format(u.expr)
        self.buf += " }"
    }

    fn coexpr(self, c: &ast::CoExpr) {
        self.buf += "co "
        self.format(c.expr.kind)
    }

    fn ident(self, id: &ast::IdentExpr) {
        if id.cpp_linked {
            self.buf += "cpp."
        }
        self.buf += id.ident
    }

    fn unary(self, u: &ast::UnaryExpr) {
        self.buf += u.op.kind
        self.format(u.expr)
    }

    fn variadic(self, v: &ast::VariadicExpr) {
        self.format(v.expr)
        self.buf += "..."
    }

    fn cast(self, c: &ast::CastExpr) {
        self.buf += "("
        self.buf += self.fmt.format_type(c.kind)
        self.buf += ")"
        self.buf += "("
        self.format(c.expr)
        self.buf += ")"
    }

    fn nselect(self, ns: &ast::NsSelectionExpr) {
        for _, s in ns.ns {
            self.buf += s.kind
            self.buf += "::"
        }
        self.buf += ns.ident.kind
    }

    fn sub_ident(self, si: &ast::SubIdentExpr) {
        self.format(si.expr)
        self.buf += "."
        self.buf += si.ident.kind
    }

    fn binary(self, bin: &ast::BinopExpr) {
        self.format(bin.left)
        self.buf += " "
        self.buf += bin.op.kind
        self.buf += " "
        self.format(bin.right)
    }

    fn args(self, &args: []&ast::Expr) {
        for i, arg in args {
            self.format(arg.kind)
            if i + 1 < args.len {
                self.buf += ", "
            }
        }
    }

    fn args_data(self, &args: []ast::ExprData) {
        for i, arg in args {
            self.format(arg)
            if i + 1 < args.len {
                self.buf += ", "
            }
        }
    }

    fn fn_call(self, f: &ast::FnCallExpr) {
        self.format(f.expr.kind)
        let tf = TypeFormatter{
            fmt: self.fmt,
        }
        tf.generics(f.generics)
        self.buf += tf.buf
        self.buf += "("
        self.args(f.args)
        self.buf += ")"
        if f.ignored() {
            self.buf += "!"
        } else if f.exception != nil {
            // SCOPE
        }
    }

    fn field_expr_pair(self, pair: &ast::FieldExprPair) {
        if pair.is_targeted() {
            self.buf += pair.field.kind
            self.buf += ": "
        }
        self.format(pair.expr)
    }

    fn struct_lit(self, lit: &ast::StructLit) {
        self.buf += self.fmt.format_type(lit.kind)
        if lit.exprs.len == 0 {
            self.buf += "{}"
            ret
        }
        self.buf += "{\n"
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.buf += self.fmt.indent
            self.format(expr)
            self.buf += ",\n"
        }
        self.fmt.done_indent()
        self.buf += "}"
    }

    fn brace_lit(self, lit: &ast::BraceLit) {
        self.buf += "{\n"
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.buf += self.fmt.indent
            self.format(expr)
            self.buf += ",\n"
        }
        self.fmt.done_indent()
        self.buf += "}"
    }

    fn key_val_pair(self, pair: &ast::KeyValPair) {
        self.format(pair.key)
        self.buf += ": "
        self.format(pair.val)
    }

    fn slice(self, s: &ast::SliceExpr) {
        self.buf += "["
        self.args_data(s.elems)
        self.buf += "]"
    }

    fn indexing(self, i: &ast::IndexingExpr) {
        self.format(i.expr)
        self.buf += "["
        self.format(i.index)
        self.buf += "]"
    }

    fn slicing(self, i: &ast::SlicingExpr) {
        self.format(i.expr)
        self.buf += "["
        self.format(i.start)
        self.buf += ":"
        self.format(i.to)
        self.buf += "]"
    }

    fn ternary(self, t: &ast::TernaryExpr) {
        self.buf += "if "
        self.format(t.condition)
        self.buf += " { "
        self.format(t.true_expr)
        self.buf += " } else { "
        self.format(t.false_expr)
        self.buf += " }"
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::Expr:
            let expr = (&ast::Expr)(kind)
            self.format(expr.kind)
        | &ast::IdentExpr:
            self.ident((&ast::IdentExpr)(kind))
        | &ast::UseExpr:
            self.usexpr((&ast::UseExpr)(kind))
        | &ast::TupleExpr:
            self.tuple((&ast::TupleExpr)(kind))
        | &ast::LitExpr:
            self.lit((&ast::LitExpr)(kind))
        | &ast::UnsafeExpr:
            self.unsafexpr((&ast::UnsafeExpr)(kind))
        | &ast::CoExpr:
            self.coexpr((&ast::CoExpr)(kind))
        | &ast::UnaryExpr:
            self.unary((&ast::UnaryExpr)(kind))
        | &ast::VariadicExpr:
            self.variadic((&ast::VariadicExpr)(kind))
        | &ast::CastExpr:
            self.cast((&ast::CastExpr)(kind))
        | &ast::NsSelectionExpr:
            self.nselect((&ast::NsSelectionExpr)(kind))
        | &ast::SubIdentExpr:
            self.sub_ident((&ast::SubIdentExpr)(kind))
        | &ast::BinopExpr:
            self.binary((&ast::BinopExpr)(kind))
        | &ast::FnCallExpr:
            self.fn_call((&ast::FnCallExpr)(kind))
        | &ast::FieldExprPair:
            self.field_expr_pair((&ast::FieldExprPair)(kind))
        | &ast::StructLit:
            self.struct_lit((&ast::StructLit)(kind))
        | &ast::BraceLit:
            self.brace_lit((&ast::BraceLit)(kind))
        | &ast::KeyValPair:
            self.key_val_pair((&ast::KeyValPair)(kind))
        | &ast::SliceExpr:
            self.slice((&ast::SliceExpr)(kind))
        | &ast::IndexingExpr:
            self.indexing((&ast::IndexingExpr)(kind))
        | &ast::SlicingExpr:
            self.slicing((&ast::SlicingExpr)(kind))
        | &ast::TernaryExpr:
            self.ternary((&ast::TernaryExpr)(kind))
        }
    }
}
