// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast::{
    Ast,
}
use lex for std::jule::lex::{
    Token,
    TokenKind,
}
use strings for std::strings

struct Formatter {
    indent_len: int = 4
    indent_str: str = " "
    
    mut i:      int
    mut buf:    str
    mut f:      &Ast
    mut indent: str
    mut cm:     CommentMap
}

impl Formatter {
    static fn new(): &Formatter {
        ret new(Formatter)
    }

    fn write(&self, s: str) {
        self.buf += s
    }

    fn add_indent(&self) {
        static indent = strings::repeat(self.indent_str, self.indent_len)
        self.indent += indent
    }

    fn done_indent(&self) {
        self.indent = self.indent[:self.indent.len - 4]
    }

    fn write_comments_except(&self, row: int) {
        for {
            let mut c = self.cm.first(row)
            if c == nil || c.row == row {
                break
            }
            self.cm.drop_first()
            self.write(self.indent)
            self.write(c.txt)
            self.write("\n")
        }
    }

    fn write_comments(&self, row: int) {
        self.write_comments_except(row + 1)
    }

    fn format_expr(&self, &expr: &ast::Expr) {
        let ef = ExprFormatter{
            fmt: self,
        }
        ef.format(expr.kind)
    }

    fn format_type(&self, &expr: &ast::TypeDecl) {
        let tf = TypeFormatter{
            fmt: self,
        }
        tf.format(expr.kind)
    }

    fn format_scope(&self, &scope: &ast::ScopeTree) {
        let sf = ScopeFormatter{
            fmt: self,
        }
        sf.format(scope)
    }

    fn directive(&self, &d: &ast::Directive) {
        self.write("#")
        self.write(d.tag.kind)
        for i, arg in d.args {
            match {
            | i == 0:
                self.write(" ")
            | arg.kind != TokenKind.RParent && d.args[i - 1].kind != TokenKind.LParent:
                self.write(" ")
            }
            self.write(arg.kind)
        }
    }

    fn directives(&self, dvs: []&ast::Directive) {
        for i, d in dvs {
            self.directive(d)
            if i + 1 < dvs.len {
                self.write("\n")
                self.write(self.indent)
            }
        }
    }

    fn use_decl(&self, d: &ast::UseDecl) {
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("use ")
        if d.alias != "" {
            self.write(d.alias)
            self.write(" for ")
        }
        if d.cpp_linked {
            self.write("\"")
            self.write(d.link_path)
            self.write("\"")
        } else {
            self.write(d.link_path)
        }
        if d.full {
            self.write("::*")
            ret
        }
        if d.selected.len == 0 {
            ret
        }
        self.write("::{\n")
        for _, s in d.selected {
            self.write("    ")
            self.write(s.kind)
            self.write(",\n")
        }
        self.write("}")
    }

    fn use_decls(&self) {
        if self.f.use_decls.len == 0 {
            ret
        }
        self.write("\n")
        for _, decl in self.f.use_decls {
            self.write("\n")
            self.write_comments(decl.token.row)
            self.use_decl(decl)
        }
        self.write("\n\n")
    }

    fn generics(&self, &g: []&ast::GenericDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for i, t in g {
            self.write(t.ident)
            if i + 1 < g.len {
                self.write(", ")
            }
        }
        self.write("]")
    }

    fn enum_decl(&self, mut d: &ast::EnumDecl) {
        if d.public {
            self.write("pub ")
        }
        self.write("enum ")
        self.write(d.ident)
        if !d.default_typed() {
            self.write(": ")
            self.format_type(d.kind)
        }
        self.write(" {\n")
        self.add_indent()
        for _, item in d.items {
            self.write_comments(item.token.row)
            self.write(self.indent)
            self.write(item.ident)
            if !item.auto_expr() {
                self.write(" = ")
                self.format_expr(item.expr)
            }
            self.write(",\n")
        }
        self.write("}")
        self.done_indent()
    }

    fn fn_decl(&self, mut d: &ast::FnDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
            self.write(self.indent)
        }
        if d.public {
            self.write("pub ")
        }
        if d.statically {
            self.write("static ")
        }
        if d.unsafety {
            self.write("unsafe ")
        }
        self.write("fn ")
        self.write(d.ident)
        self.generics(d.generics)
        self.write("(")
        for i, p in d.params {
            if p.mutable {
                self.write("mut ")
            }
            if p.reference {
                self.write("&")
            }
            if p.is_self() {
                self.write("self")
            } else {
                if !lex::is_anon_ident(p.ident) {
                    self.write(p.ident)
                    self.write(": ")
                } else if p.reference {
                    self.write("_: ")
                }
                self.format_type(p.kind)
            }
            if i + 1 < d.params.len {
                self.write(", ")
            }
        }
        self.write(")")
        if d.scope != nil {
            self.write(" ")
            let unsafety = d.unsafety
            d.scope.unsafety = false // Avoid unsafe keyword beginning of scope.
            self.format_scope(d.scope)
            d.scope.unsafety = unsafety
        }
    }

    fn fields(&self, &fields: []&ast::FieldDecl, public: bool, mutable: bool, n: int) {
        for _, f in fields {
            if f.public != public || f.mutable != mutable {
                continue
            }
            self.write(self.indent)
            if f.public {
                self.write("pub ")
            }
            if f.mutable {
                self.write("mut ")
            }
            self.write(f.ident)
            self.write(": ")
            let diff = n - f.ident.len
            if diff > 0 {
                self.write(strings::repeat(" ", diff))
            }
            self.format_type(f.kind)
            self.write("\n")
        }
    }

    fn struct_decl(&self, mut d: &ast::StructDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.public {
            self.write("pub ")
        }
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("struct ")
        self.write(d.ident)
        self.generics(d.generics)
        if d.fields.len == 0 {
            self.write(" {}")
            ret
        }
        let (p, pm, pb, pbm) = max_field_len(d.fields)
        _ = pm, pb, pbm
        self.write(" {\n")
        self.add_indent()
        if p > 0 {
            self.fields(d.fields, false, false, p)
        }
        if pm > 0 {
            if p > 0 {
                self.write("\n")
            }
            self.fields(d.fields, false, true, pm)
        }
        if pb > 0 {
            if pm > 0 {
                self.write("\n")
            }
            self.fields(d.fields, true, false, pb)
        }
        if pbm > 0 {
            if pb > 0 {
                self.write("\n")
            }
            self.fields(d.fields, true, true, pbm)
        }
        self.done_indent()
        self.write("}")
    }

    fn trait_decl(&self, mut d: &ast::TraitDecl) {
        if d.public {
            self.write("pub ")
        }
        self.write("trait ")
        self.write(d.ident)
        if d.methods.len == 0 {
            self.write(" {}")
            ret
        }
        self.write(" {")
        self.add_indent()
        for (_, mut m) in d.methods {
            self.write("\n")
            self.write_comments(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.write("\n")
        }
        self.done_indent()
        self.write("}")
    }

    fn type_alias_decl(&self, d: &ast::TypeAliasDecl) {
        if d.public {
            self.write("pub ")
        }
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("type ")
        self.write(d.ident)
        self.write(": ")
        self.format_type(d.kind)
    }

    fn var_decl(&self, d: &ast::VarDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.cpp_linked {
            self.write("cpp let ")
        } else {
            if d.public {
                self.write("pub ")
            }
            if d.statically {
                self.write("static ")
            } else  if d.constant {
                self.write("const ")
            } else {
                self.write("let ")
            }
        }
        if d.mutable {
            self.write("mut ")
        }
        if d.reference {
            self.write("&")
        }
        self.write(d.ident)
        if d.kind != nil {
            self.write(": ")
            self.format_type(d.kind)
        }
        if d.expr != nil {
            self.write(" = ")
            self.format_expr(d.expr)
        }
    }

    fn group_decls[T](&self, nodes: []ast::Node, mut &i: int) {
        const CAP = 1 << 4
        let mut lines = make([]str, 0, CAP)
        let mut comments = make([]&Comment, 0, CAP)

        let mut row = -1
        let mut max = 0
        for i < nodes.len {
            let node = nodes[i]
            match type node.data {
            | T:
                let decl = T(node.data)
                if row == -1 || decl.token.row - 1 == row {
                    row = decl.token.row
                    self.write_comments_except(row)
                    if self.cm.map.len > 0 && self.cm.map[0].row == row {
                        comments = append(comments, self.cm.pop(row))
                    } else {
                        let mut c: &Comment
                        comments = append(comments, c)
                    }
                    let n = self.buf.len
                    match type T {
                    | &ast::VarDecl:
                        self.var_decl(decl)
                    | &ast::TypeAliasDecl:
                        self.type_alias_decl(decl)
                    }
                    let diff = self.buf.len - n
                    if max < diff {
                        max = diff
                    }
                    lines = append(lines, self.buf[n:])
                    self.buf = self.buf[:self.buf.len - diff]
                    i++
                    continue
                }
            }
            break
        }

        for j, line in lines {
            self.write(line)
            let c = comments[j]
            if c != nil {
                self.write(strings::repeat(" ", max - line.len + 1))
                self.write(c.txt)
            }
            self.write("\n")
        }
    }

    fn impl_decl(&self, mut d: &ast::Impl) {
        self.write("impl ")
        if d.is_trait_impl() {
            self.format_type(d.base)
            self.write(" for ")
        }
        self.format_type(d.dest)
        if d.methods.len == 0 && d.statics.len == 0 {
            self.write(" {}")
            ret
        }
        self.write(" {\n")
        self.add_indent()
        for (_, mut s) in d.statics {
            self.write_comments(s.token.row)
            self.write(self.indent)
            self.var_decl(s)
            self.write("\n")
        }
        for (_, mut m) in d.methods {
            self.write("\n")
            self.write_comments(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.write("\n")
        }
        self.done_indent()
        self.write("}")
    }

    fn node(&self, mut &node: ast::Node) {
        match type node.data {
        | &ast::TypeAliasDecl:
            self.group_decls[&ast::TypeAliasDecl](self.f.nodes, self.i)
        | &ast::VarDecl:
            self.group_decls[&ast::VarDecl](self.f.nodes, self.i)
        }

        self.write_comments(node.token.row)
        match type node.data {
        | &ast::EnumDecl:
            self.enum_decl((&ast::EnumDecl)(node.data))
        | &ast::FnDecl:
            self.fn_decl((&ast::FnDecl)(node.data))
        | &ast::StructDecl:
            self.struct_decl((&ast::StructDecl)(node.data))
        | &ast::TraitDecl:
            self.trait_decl((&ast::TraitDecl)(node.data))
        | &ast::Impl:
            self.impl_decl((&ast::Impl)(node.data))
        }
    }

    fn nodes(&self) {
        self.i = 0
        let mut row = 0
        for self.i < self.f.nodes.len; self.i++ {
            let mut node = self.f.nodes[self.i]
            let old = self.i
            self.node(node)
            match {
            | old != self.i:
                self.i--
                fall
            | row + 1 == node.token.row:
                self.write("\n")
            |:
                self.write("\n\n")
            }
            row = node.token.row
        }
    }

    fn format(&self, mut &f: &Ast, mut &cm: CommentMap): str {
        self.cm = cm
        self.f = f
        self.directives(self.f.top_directives)
        self.use_decls()
        self.nodes()
        self.f = nil
        ret strings::trim(self.buf, " \n\r\v\t")
    }
}

struct TypeFormatter {
    mut fmt: &Formatter
}

impl TypeFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn generics(self, g: []&ast::TypeDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for i, t in g {
            self.format(t.kind)
            if i + 1 < g.len {
                self.write(",")
            }
        }
        self.write("]")
    }

    fn ident(self, id: &ast::IdentTypeDecl) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
        self.generics(id.generics)
    }

    fn namespace(self, ns: &ast::NamespaceTypeDecl) {
        for _, id in ns.idents {
            self.write(id.kind)
            self.write("::")
        }
        self.ident(ns.kind)
    }

    fn sptr(self, sptr: &ast::SptrTypeDecl) {
        self.write("&")
        self.format(sptr.elem.kind)
    }

    fn slc(self, slc: &ast::SlcTypeDecl) {
        self.write("[]")
        self.format(slc.elem.kind)
    }

    fn ptr(self, ptr: &ast::PtrTypeDecl) {
        self.write("*")
        if ptr.is_unsafe() {
            self.write("unsafe")
            ret
        }
        self.format(ptr.elem.kind)
    }

    fn arr(self, arr: &ast::ArrTypeDecl) {
        self.write("[")
        if arr.auto_sized() {
            self.write("...")
        } else {
            self.fmt.format_expr(arr.size)
        }
        self.write("]")
        self.format(arr.elem.kind)
    }

    fn map(self, map: &ast::MapTypeDecl) {
        self.write("[")
        self.format(map.key.kind)
        self.write(":")
        self.format(map.val.kind)
        self.write("]")
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::IdentTypeDecl:
            self.ident((&ast::IdentTypeDecl)(kind))
        | &ast::NamespaceTypeDecl:
            self.namespace((&ast::NamespaceTypeDecl)(kind))
        | &ast::SptrTypeDecl:
            self.sptr((&ast::SptrTypeDecl)(kind))
        | &ast::SlcTypeDecl:
            self.slc((&ast::SlcTypeDecl)(kind))
        | &ast::PtrTypeDecl:
            self.ptr((&ast::PtrTypeDecl)(kind))
        | &ast::ArrTypeDecl:
            self.arr((&ast::ArrTypeDecl)(kind))
        | &ast::MapTypeDecl:
            self.map((&ast::MapTypeDecl)(kind))
        }
    }
}

struct ScopeFormatter {
    mut fmt: &Formatter
}

impl ScopeFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn usexpr(self, u: &ast::UseExpr) {
        self.write("use ")
        self.fmt.format_expr(u.expr)
    }

    fn co_expr(self, expr: &ast::CoExpr) {
        self.write("co ")
        self.fmt.format_expr(expr.expr)
    }

    fn label(self, l: &ast::LabelSt) {
        // Remove one indentation.
        self.fmt.buf = self.fmt.buf[:self.fmt.buf.len - self.fmt.indent_len]
        self.write(l.ident)
        self.write(":")
    }

    fn goto_st(self, g: &ast::GotoSt) {
        self.write("goto ")
        self.write(g.label.kind)
    }

    fn fall_st(self, fll: &ast::FallSt) {
        self.write("fall")
    }

    fn cont_st(self, cont: &ast::ContSt) {
        self.write("continue ")
        self.write(cont.label.kind)
    }

    fn break_st(self, brk: &ast::BreakSt) {
        self.write("break ")
        self.write(brk.label.kind)
    }

    fn ret_st(self, r: &ast::RetSt) {
        self.write("ret ")
        self.fmt.format_expr(r.expr)
    }

    fn iter(self, it: &ast::Iter) {
        self.write("for")
        if !it.is_inf() {
            match type it.kind {
            | &ast::WhileKind:
                self.write(" ")
                let wk = (&ast::WhileKind)(it.kind)
                self.fmt.format_expr(wk.expr)
            | &ast::RangeKind:
                self.write(" ")
                let rk = (&ast::RangeKind)(it.kind)
                let p = (rk.key_a != nil && rk.key_a.mutable) || (rk.key_b != nil && rk.key_b.mutable)
                if p {
                    self.write("(")
                }
                if rk.key_a != nil {
                    if rk.key_a.mutable {
                        self.write("mut ")
                    }
                    self.write(rk.key_a.ident)
                }
                if rk.key_b != nil {
                    self.write(", ")
                    if rk.key_b.mutable {
                        self.write("mut ")
                    }
                    self.write(rk.key_b.ident)
                }
                if p {
                    self.write(")")
                }
                self.write(" in ")
                self.fmt.format_expr(rk.expr)
            }
        }
        self.write(" ")
        self.format(it.scope)
    }

    fn conditional_case(self, c: &ast::If) {
        self.write("if ")
        self.fmt.format_expr(c.expr)
        self.write(" ")
        self.format(c.scope)
    }

    fn conditional(self, c: &ast::Conditional) {
        self.conditional_case(c.head)
        for _, t in c.tail {
            self.write(" else ")
            self.conditional_case(t)
        }
        if c.default != nil {
            self.write(" else ")
            self.format(c.default.scope)
        }
    }

    fn match_case(self, mc: &ast::MatchCase) {
        self.write("match ")
        if mc.type_match {
            self.write("type ")
        }
        if mc.expr != nil {
            self.fmt.format_expr(mc.expr)
            self.write(" ")
        }
        self.write("{\n")
        for _, c in mc.cases {
            self.write(self.fmt.indent)
            for i, expr in c.exprs {
                if i > 0 {
                    self.write(" ")
                }
                self.write("| ")
                self.fmt.format_expr(expr)
            }
            self.write(":\n")
            self.fmt.add_indent()
            self.format_stmts(c.scope.stmts)
            self.fmt.done_indent()
        }
        if mc.default != nil {
            self.write(self.fmt.indent)
            self.write("|:\n")
            self.fmt.add_indent()
            self.format_stmts(mc.default.scope.stmts)
            self.fmt.done_indent()
        }
        self.write(self.fmt.indent)
        self.write("}")
    }

    fn postfix(self, &a: &ast::AssignSt) {
        let expr = a.left[0].expr
        self.fmt.format_expr(expr)
        self.write(a.setter.kind)
    }

    fn single_assign(self, &a: &ast::AssignSt) {
        if lex::is_ignore_ident(a.left[0].ident) {
            self.write("_ ")
        } else {
            let expr = a.left[0].expr
            self.fmt.format_expr(expr)
            self.write(" ")
        }
        self.write(a.setter.kind)
        self.write(" ")
        self.fmt.format_expr(a.right)
    }

    fn multi_assign(self, &a: &ast::AssignSt) {
        self.write("let (")
        for i, l in a.left {
            if l.ident != "" {
                if l.mutable {
                    self.write("mut ")
                }
                if l.reference {
                    self.write("&")
                }
                self.write(l.ident)
            } else {
                self.write("(")
                self.fmt.format_expr(l.expr)
                self.write(")")
            }
            if i + 1 < a.left.len {
                self.write(", ")
            }
        }
        self.write(") = ")
        self.fmt.format_expr(a.right)
    }

    fn assign(self, a: &ast::AssignSt) {
        match {
        | lex::is_postfix_op(a.setter.kind):
            self.postfix(a)
        | a.left.len == 1 && !a.declarative:
            self.single_assign(a)
        |:
            self.multi_assign(a)
        }
    }

    fn format_stmt(self, &stmt: ast::NodeData) {
        match type stmt {
        | &ast::ScopeTree:
            self.format((&ast::ScopeTree)(stmt))
        | &ast::Expr:
            let expr = (&ast::Expr)(stmt)
            self.fmt.format_expr(expr)
        | &ast::VarDecl:
            self.fmt.var_decl((&ast::VarDecl)(stmt))
        | &ast::CoExpr:
            self.co_expr((&ast::CoExpr)(stmt))
        | &ast::TypeAliasDecl:
            self.fmt.type_alias_decl((&ast::TypeAliasDecl)(stmt))
        | &ast::LabelSt:
            self.label((&ast::LabelSt)(stmt))
        | &ast::GotoSt:
            self.goto_st((&ast::GotoSt)(stmt))
        | &ast::UseExpr:
            self.usexpr((&ast::UseExpr)(stmt))
        | &ast::FallSt:
            self.fall_st((&ast::FallSt)(stmt))
        | &ast::ContSt:
            self.cont_st((&ast::ContSt)(stmt))
        | &ast::BreakSt:
            self.break_st((&ast::BreakSt)(stmt))
        | &ast::RetSt:
            self.ret_st((&ast::RetSt)(stmt))
        | &ast::Iter:
            self.iter((&ast::Iter)(stmt))
        | &ast::Conditional:
            self.conditional((&ast::Conditional)(stmt))
        | &ast::MatchCase:
            self.match_case((&ast::MatchCase)(stmt))
        | &ast::AssignSt:
            self.assign((&ast::AssignSt)(stmt))
        }
    }

    fn format_stmts(self, &stmts: []&ast::Node) {
        for _, stmt in stmts {
            self.fmt.write_comments(stmt.token.row)
            self.write(self.fmt.indent)
            self.format_stmt(stmt.data)
            self.write("\n")
        }
    }

    fn format(self, scope: &ast::ScopeTree) {
        if scope.unsafety {
            self.write("unsafe ")
        }
        if scope.deferred {
            self.write("defer ")
        }
        if scope.stmts.len == 0 {
            self.write("{}")
            ret
        }
        self.write("{\n")
        self.fmt.add_indent()
        self.format_stmts(scope.stmts)
        self.fmt.done_indent()
        self.write(self.fmt.indent)
        self.write("}")
    }
}

struct ExprFormatter {
    mut fmt: &Formatter
}

impl ExprFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn tuple(self, tup: &ast::TupleExpr) {
        for i, expr in tup.expr {
            self.format(expr.kind)
            if i + 1 < tup.expr.len {
                self.write(", ")
            }
        }
    }

    fn lit(self, l: &ast::LitExpr) {
        self.write(l.value)
    }

    fn unsafexpr(self, u: &ast::UnsafeExpr) {
        self.write("unsafe { ")
        self.format(u.expr)
        self.write(" }")
    }

    fn coexpr(self, c: &ast::CoExpr) {
        self.write("co ")
        self.format(c.expr.kind)
    }

    fn ident(self, id: &ast::IdentExpr) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
    }

    fn unary(self, u: &ast::UnaryExpr) {
        self.write(u.op.kind)
        self.format(u.expr)
    }

    fn variadic(self, v: &ast::VariadicExpr) {
        self.format(v.expr)
        self.write("...")
    }

    fn cast(self, c: &ast::CastExpr) {
        self.write("(")
        self.fmt.format_type(c.kind)
        self.write(")")
        self.write("(")
        self.format(c.expr)
        self.write(")")
    }

    fn nselect(self, ns: &ast::NsSelectionExpr) {
        for _, s in ns.ns {
            self.write(s.kind)
            self.write("::")
        }
        self.write(ns.ident.kind)
    }

    fn sub_ident(self, si: &ast::SubIdentExpr) {
        self.format(si.expr)
        self.write(".")
        self.write(si.ident.kind)
    }

    fn binary(self, bin: &ast::BinopExpr) {
        self.format(bin.left)
        self.write(" ")
        self.write(bin.op.kind)
        self.write(" ")
        self.format(bin.right)
    }

    fn args(self, &args: []&ast::Expr) {
        for i, arg in args {
            self.format(arg.kind)
            if i + 1 < args.len {
                self.write(", ")
            }
        }
    }

    fn args_data(self, &args: []ast::ExprData) {
        for i, arg in args {
            self.format(arg)
            if i + 1 < args.len {
                self.write(", ")
            }
        }
    }

    fn fn_call(self, f: &ast::FnCallExpr) {
        self.format(f.expr.kind)
        let tf = TypeFormatter{
            fmt: self.fmt,
        }
        tf.generics(f.generics)
        self.write("(")
        self.args(f.args)
        self.write(")")
        if f.ignored() {
            self.write("!")
        } else if f.exception != nil {
            self.write(" ")
            self.fmt.format_scope(f.exception)
        }
    }

    fn field_expr_pair(self, pair: &ast::FieldExprPair) {
        if pair.is_targeted() {
            self.write(pair.field.kind)
            self.write(": ")
        }
        self.format(pair.expr)
    }

    fn struct_lit(self, lit: &ast::StructLit) {
        self.fmt.format_type(lit.kind)
        if lit.exprs.len == 0 {
            self.write("{}")
            ret
        }
        self.write("{\n")
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.write(self.fmt.indent)
            self.format(expr)
            self.write(",\n")
        }
        self.fmt.done_indent()
        self.write("}")
    }

    fn brace_lit(self, lit: &ast::BraceLit) {
        self.write("{\n")
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.write(self.fmt.indent)
            self.format(expr)
            self.write(",\n")
        }
        self.fmt.done_indent()
        self.write("}")
    }

    fn key_val_pair(self, pair: &ast::KeyValPair) {
        self.format(pair.key)
        self.write(": ")
        self.format(pair.val)
    }

    fn slice(self, s: &ast::SliceExpr) {
        self.write("[")
        self.args_data(s.elems)
        self.write("]")
    }

    fn indexing(self, i: &ast::IndexingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.index)
        self.write("]")
    }

    fn slicing(self, i: &ast::SlicingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.start)
        self.write(":")
        self.format(i.to)
        self.write("]")
    }

    fn ternary(self, t: &ast::TernaryExpr) {
        self.write("if ")
        self.format(t.condition)
        self.write(" { ")
        self.format(t.true_expr)
        self.write(" } else { ")
        self.format(t.false_expr)
        self.write(" }")
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::Expr:
            let expr = (&ast::Expr)(kind)
            self.format(expr.kind)
        | &ast::IdentExpr:
            self.ident((&ast::IdentExpr)(kind))
        | &ast::TupleExpr:
            self.tuple((&ast::TupleExpr)(kind))
        | &ast::LitExpr:
            self.lit((&ast::LitExpr)(kind))
        | &ast::UnsafeExpr:
            self.unsafexpr((&ast::UnsafeExpr)(kind))
        | &ast::CoExpr:
            self.coexpr((&ast::CoExpr)(kind))
        | &ast::UnaryExpr:
            self.unary((&ast::UnaryExpr)(kind))
        | &ast::VariadicExpr:
            self.variadic((&ast::VariadicExpr)(kind))
        | &ast::CastExpr:
            self.cast((&ast::CastExpr)(kind))
        | &ast::NsSelectionExpr:
            self.nselect((&ast::NsSelectionExpr)(kind))
        | &ast::SubIdentExpr:
            self.sub_ident((&ast::SubIdentExpr)(kind))
        | &ast::BinopExpr:
            self.binary((&ast::BinopExpr)(kind))
        | &ast::FnCallExpr:
            self.fn_call((&ast::FnCallExpr)(kind))
        | &ast::FieldExprPair:
            self.field_expr_pair((&ast::FieldExprPair)(kind))
        | &ast::StructLit:
            self.struct_lit((&ast::StructLit)(kind))
        | &ast::BraceLit:
            self.brace_lit((&ast::BraceLit)(kind))
        | &ast::KeyValPair:
            self.key_val_pair((&ast::KeyValPair)(kind))
        | &ast::SliceExpr:
            self.slice((&ast::SliceExpr)(kind))
        | &ast::IndexingExpr:
            self.indexing((&ast::IndexingExpr)(kind))
        | &ast::SlicingExpr:
            self.slicing((&ast::SlicingExpr)(kind))
        | &ast::TernaryExpr:
            self.ternary((&ast::TernaryExpr)(kind))
        }
    }
}

// Returns maximum length of field identifiers.
// Length is calucated with public, mutable and identifier length, not including type.
// Returns length for private, private mut, public, public mut fields.
fn max_field_len(&fields: []&ast::FieldDecl): (p: int, pm: int, pb: int, pbm: int) {
    for _, f in fields {
        let n = f.ident.len
        match {
        | f.mutable:
            if f.public && n > pbm {
                pbm = n
            } else if !f.public && n > pm {
                pm = n
            }
        | f.public:
            if n > pb {
                pb = n
            }
        |:
            if n > p {
                p = n
            }
        }
    }
    ret
}
