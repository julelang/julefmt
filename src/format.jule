// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast::{
    Ast,
}
use lex for std::jule::lex::{
    Token,
    TokenKind,
}
use strings for std::strings

struct Field {
    f:     &ast::FieldDecl
    token: Token
    expr:  str
}

struct RowAlign {
    row: int
    max: bool
}

struct Formatter {
    indent_len: int = 4
    indent_str: str = " "
    
    mut i:      int
    mut buf:    str
    mut f:      &Ast
    mut indent: str
    mut cm:     CommentMap
    mut row:    int

    mut ef: &ExprFormatter
    mut sf: &ScopeFormatter
    mut tf: &TypeFormatter
}

impl Formatter {
    static fn new(): &Formatter {
        let mut fmt = new(Formatter)
        fmt.ef = &ExprFormatter{fmt: fmt}
        fmt.sf = &ScopeFormatter{fmt: fmt}
        fmt.tf = &TypeFormatter{fmt: fmt}
        ret fmt
    }

    fn write(&self, s: str) {
        self.buf += s
    }

    fn add_indent(&self) {
        static indent = strings::repeat(self.indent_str, self.indent_len)
        self.indent += indent
    }

    fn done_indent(&self) {
        self.indent = self.indent[:self.indent.len - 4]
    }

    fn write_comment(&self, &c: &Comment) {
        if self.indent.len > 0 && c.txt[1] == '*' {
            // Range comment should be checked.
            // Endind is should be padded by indentation.
            let mut i = c.txt.len - 3
        lookup:
            for i > 1; i-- {
                let b = c.txt[i]
                match b {
                | ' ' | '\t' | '\v' | '\r':
                    continue
                | '\n':
                    let cmt = c.txt[:i + 1]
                    i = strings::find_last(self.buf, "\n")
                    let n = self.buf.len - i - 1
                    self.write(cmt)
                    self.write(strings::repeat(" ", n))
                    self.write("*/")
                    ret
                |:
                    break lookup
                }
            }
        }
        self.write(c.txt)
    }

    fn write_comments_except(&self, row: int): int {
        let mut lrow = row
        for {
            let mut c = self.cm.first(row)
            if c == nil || (row != -1 && c.row == row) {
                break
            }
            if c.row - lrow > 1 {
                self.write("\n")
            }
            lrow = c.row
            self.cm.drop_first()
            self.write(self.indent)
            self.write_comment(c)
            self.write("\n")
        }
        ret lrow
    }

    fn write_comments(&self, row: int): int {
        ret self.write_comments_except(row + 1)
    }

    fn add_global_padding_for_comment(&self, row: int) {
        let c = self.cm.first(row)
        if c != nil && c.row - self.row > 1 {
            self.write("\n")
        }
    }

    fn write_remaining_comments(&self) {
        self.add_global_padding_for_comment(-1)
        self.write_comments_except(-1)
    }

    fn pop_row_comments_by_f(&self, row: int, col: int, f: fn(_: &Comment)) {
        let mut i = 0
        for i < self.cm.map.len {
            let c = self.cm.map[i]
            if c.row == row && (col == -1 || c.col < col) {
                f(c)
                self.cm.map = append(self.cm.map[:i], self.cm.map[i + 1:]...)
                continue
            } else if c.row > row {
                break
            }
            i++
        }
    }

    fn pop_row_comments_by(&self, row: int) {
        self.pop_row_comments_by_f(row, -1, fn(c: &Comment) {
            self.write(" ")
            self.write_comment(c)
        })
    }

    fn pop_row_comments_by_c(&self, row: int, col: int) {
        self.pop_row_comments_by_f(row, col, fn(c: &Comment) {
            self.write(c.txt)
            self.write(" ")
        })
    }

    fn pop_row_comments(&self, row: int) {
        for {
            let c = self.cm.pop(row)
            if c == nil {
                break
            }
            self.write(" ")
            self.write_comment(c)
        }
    }

    fn format_expr(&self, mut &expr: &ast::Expr) {
        self.ef.format(expr)
    }

    fn format_type(&self, mut &expr: &ast::TypeDecl) {
        self.tf.format(expr.kind)
    }

    fn format_scope(&self, mut &scope: &ast::ScopeTree) {
        self.sf.format(scope)
    }

    fn directive(&self, &d: &ast::Directive) {
        self.write("#")
        self.write(d.tag.kind)
        for i, arg in d.args {
            match {
            | i == 0:
                self.write(" ")
            | arg.kind != TokenKind.RParent && d.args[i - 1].kind != TokenKind.LParent:
                self.write(" ")
            }
            self.write(arg.kind)
        }
    }

    fn directives(&self, dvs: []&ast::Directive) {
        if dvs.len == 0 {
            ret
        }
        let first = dvs[0]
        if first.tag.row - self.write_comments_except(first.tag.row) > 1 {
            self.write("\n")
        }
        for i, d in dvs {
            self.write_comments_except(d.tag.row)
            self.directive(d)
            self.pop_row_comments(d.tag.row)
            if i + 1 < dvs.len {
                self.write("\n")
                self.write(self.indent)
            }
            self.row = d.tag.row
        }
    }

    fn use_decl(&self, d: &ast::UseDecl) {
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("use ")
        if d.alias != "" {
            self.write(d.alias)
            self.write(" for ")
        }
        if d.cpp_linked {
            self.write("\"")
            self.write(d.link_path)
            self.write("\"")
        } else {
            self.write(d.link_path)
        }
        if d.full {
            self.write("::*")
            ret
        }
        if d.selected.len == 0 {
            ret
        }
        let mut newline = false
        let mut row = d.token.row
        for _, s in d.selected {
            if row != s.row {
                newline = true
                break
            }
        }
        self.write("::{")
        if newline {
            self.add_indent()
            self.write("\n")
        }
        for i, s in d.selected {
            if newline {
                self.write(self.indent)
            }
            self.write(s.kind)
            if newline {
                self.write(",\n")
            } else if i + 1 < d.selected.len {
                self.write(", ")
            }
        }
        if newline {
            self.done_indent()
        }
        self.write("}")
    }

    fn use_decls(&self) {
        if self.f.use_decls.len == 0 {
            ret
        }
        let first = self.f.use_decls[0]
        if first.token.row - self.row != 0 {
            self.write("\n")
        }
        for _, decl in self.f.use_decls {
            self.row = decl.token.row
            self.write("\n")
            self.write_comments(self.row)
            self.use_decl(decl)
        }
    }

    fn generics(&self, &g: []&ast::GenericDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for i, t in g {
            self.write(t.ident)
            if i + 1 < g.len {
                self.write(", ")
            }
        }
        self.write("]")
    }

    fn enum_item(&self, mut &item: &ast::EnumItemDecl) {
        self.write(self.indent)
        self.write(item.ident)
        if !item.auto_expr() {
            self.write(" = ")
            self.format_expr(item.expr)
        }
        self.write(",")
    }

    fn enum_decl(&self, mut d: &ast::EnumDecl) {
        if d.public {
            self.write("pub ")
        }
        self.write("enum ")
        self.write(d.ident)
        if !d.default_typed() {
            self.write(": ")
            self.format_type(d.kind)
        }
        self.write(" {\n")
        self.add_indent()
        let (mut i, mut row) = 0, 0
        for i < d.items.len {
            let old = self.i
            let item = d.items[i]
            self.group_decls[&ast::EnumItemDecl, &ast::EnumItemDecl](d.items, i)
            if old != i {
                if i < d.items.len {
                    self.write("\n")
                }
            } else {
                i++
            }
            row = item.token.row
        }
        self.add_global_padding_for_comment(d.end.row)
        self.write_comments_except(d.end.row)
        self.write("}")
        self.done_indent()
        self.pop_row_comments(d.end.row)
        self.row = d.end.row
    }

    fn fn_decl(&self, mut d: &ast::FnDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
            self.write(self.indent)
        }
        if d.public {
            self.write("pub ")
        }
        if d.statically {
            self.write("static ")
        }
        if d.unsafety {
            self.write("unsafe ")
        }
        self.write("fn ")
        if !lex::is_anon_ident(d.ident) {
            self.write(d.ident)
        }
        self.generics(d.generics)
        self.write("(")
        for (i, mut p) in d.params {
            if p.mutable {
                self.write("mut ")
            }
            if p.reference {
                self.write("&")
            }
            if p.is_self() {
                self.write("self")
            } else {
                if !lex::is_anon_ident(p.ident) {
                    self.write(p.ident)
                    self.write(": ")
                } else if p.reference {
                    self.write("_: ")
                }
                self.format_type(p.kind)
            }
            if i + 1 < d.params.len {
                self.write(", ")
            }
        }
        self.write(")")
        if d.scope != nil {
            self.write(" ")
            let unsafety = d.unsafety
            d.scope.unsafety = false // Avoid unsafe keyword beginning of scope.
            self.format_scope(d.scope)
            d.scope.unsafety = unsafety
            self.row = d.scope.end.row
        } else {
            self.row = d.token.row
        }
    }

    // Only parses last field.
    // Leading fields used to calculate maximum declaration length of group for padding.
    fn field(&self, mut f: &Field, mut max: int) {
        self.write(self.indent)
        if f.f.public {
            self.write("pub ")
            max -= 4
        }
        if f.f.mutable {
            self.write("mut ")
            max -= 4
        }
        self.write(f.f.ident)
        max -= f.f.ident.len
        self.write(": ")
        if max > 0 {
            self.write(strings::repeat(" ", max))
        }
        self.format_type(f.f.kind)
        if f.expr != "" {
            self.write(" = ")
            self.write(f.expr)
        }
    }

    fn fields(&self, mut &fields: []&ast::FieldDecl) {
        let mut flds = make([]&Field, 0, fields.len)
        for (_, mut f) in fields {
            flds = append(flds, &Field{
                f:     f,
                token: f.token,
            })
        }
        let (mut i, mut row) = 0, 0
        for i < flds.len {
            let old = self.i
            let f = flds[i]
            self.field_group_decls(flds, i)
            if old != i {
                if i < flds.len {
                    self.write("\n")
                }
            } else {
                i++
            }
            row = f.token.row
        }
    }

    fn struct_decl(&self, mut d: &ast::StructDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.public {
            self.write("pub ")
        }
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("struct ")
        self.write(d.ident)
        self.generics(d.generics)
        if d.fields.len == 0 {
            self.write(" {}")
            ret
        }
        self.write(" {\n")
        self.add_indent()
        self.fields(d.fields)
        self.add_global_padding_for_comment(d.end.row)
        self.write_comments_except(d.end.row)
        self.done_indent()
        self.write("}")
        self.pop_row_comments(d.end.row)
        self.row = d.end.row
    }

    fn trait_decl(&self, mut d: &ast::TraitDecl) {
        if d.public {
            self.write("pub ")
        }
        self.write("trait ")
        self.write(d.ident)
        if d.methods.len == 0 {
            self.write(" {}")
            ret
        }
        self.write(" {")
        self.add_indent()
        for (_, mut m) in d.methods {
            self.write("\n")
            self.write_comments_except(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.pop_row_comments(m.token.row)
            self.write("\n")
        }
        self.add_global_padding_for_comment(d.end.row)
        self.write_comments_except(d.end.row)
        self.done_indent()
        self.write("}")
        self.pop_row_comments(d.end.row)
        self.row = d.end.row
    }

    fn type_alias_decl(&self, mut d: &ast::TypeAliasDecl) {
        self.write(self.indent)
        if d.public {
            self.write("pub ")
        }
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("type ")
        self.write(d.ident)
        self.write(": ")
        self.format_type(d.kind)
    }

    fn var_decl(&self, mut d: &ast::VarDecl) {
        self.write(self.indent)
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.cpp_linked {
            self.write("cpp let ")
        } else {
            if d.public {
                self.write("pub ")
            }
            if d.statically {
                self.write("static ")
            } else  if d.constant {
                self.write("const ")
            } else {
                self.write("let ")
            }
        }
        if d.mutable {
            self.write("mut ")
        }
        if d.reference {
            self.write("&")
        }
        self.write(d.ident)
        if d.kind != nil {
            self.write(": ")
            self.format_type(d.kind)
        }
        if d.expr != nil {
            self.write(" = ")
            self.format_expr(d.expr)
        }
    }

    fn field_group_decls(&self, mut fields: []&Field, mut &i: int) {
        const CAP = 1 << 4
        let mut lines = make([]str, 0, CAP)
        let mut rows = make([]int, 0, CAP)

        let mut start = i
        self.row = -1
        let mut max = 0
        let mut field_max = 0
        let n = self.buf.len
        for i < fields.len {
            let mut decl =  fields[i]
            if self.row != -1 && decl.token.row - 1 != self.row {
                break
            }
            self.row = decl.token.row
            let mut fm = 0
            if decl.f.public {
                fm += "pub ".len
            }
            if decl.f.mutable {
                fm += "mut ".len
            }
            fm += decl.f.ident.len
            if fm > field_max {
                field_max = fm
            }
            i++
            if decl.f.default != nil {
                self.format_expr(decl.f.default)
                decl.expr = self.buf[n:]
                self.buf = self.buf[:n]
            }
            rows = append(rows, self.row)
        }

        let mut j = start
        for j < i; j++ {
            let mut f = fields[j]
            self.field(f, field_max)
            lines = append(lines, self.buf[n:])
            let diff = self.buf.len - n
            if max < diff && f.f.token.row == rows[j - start] {
                max = diff
            }
            self.buf = self.buf[:self.buf.len - diff]
        }

        for k, line in lines {
            let row = rows[k]
            self.write_comments_except(row)
            self.write(line)
            self.pop_row_comments_by_f(row, -1, fn (c: &Comment) {
                self.write(strings::repeat(" ", padding_abs(max - line.len) + 1))
                self.write_comment(c)
            })
            self.write("\n")
            start++
        }
    }

    fn group_decls[T, Node](&self, mut nodes: []Node, mut &i: int) {
        const CAP = 1 << 4
        let mut lines = make([]str, 0, CAP)
        let mut rows = make([]int, 0, CAP)

        let all = i == -1
        if all {
            i = 0
        }

        self.row = -1
        let mut max = 0
        let n = self.buf.len
    loop:
        for i < nodes.len {
            let mut decl: T =  nil
            match type Node {
            | &ast::EnumItemDecl
            | &ast::VarDecl:
                decl = nodes[i]
            | ast::Node:
                let node = nodes[i]
                match type node.data {
                | T:
                    decl = (T)(nodes[i].data)
                |:
                    break loop
                }
            }
            if !all && self.row != -1 && decl.token.row - 1 != self.row {
                break loop
            }
            self.row = decl.token.row
            let row = self.row
            match type T {
            | &ast::VarDecl:
                self.var_decl(decl)
            | &ast::TypeAliasDecl:
                self.type_alias_decl(decl)
            | &ast::EnumItemDecl:
                self.enum_item(decl)
            }
            let diff = self.buf.len - n
            if max < diff && row == self.row {
                max = diff
            }
            lines = append(lines, self.buf[n:])
            rows = append(rows, self.row)
            self.buf = self.buf[:self.buf.len - diff]
            i++
        }

        for j, line in lines {
            let row = rows[j]
            self.write_comments_except(row)
            self.write(line)
            self.pop_row_comments_by_f(row, -1, fn(c: &Comment) {
                self.write(strings::repeat(" ", padding_abs(max - line.len) + 1))
                self.write_comment(c)
            })
            self.write("\n")
        }
    }

    fn impl_decl(&self, mut d: &ast::Impl) {
        self.write("impl ")
        if d.is_trait_impl() {
            self.format_type(d.base)
            self.write(" for ")
        }
        self.format_type(d.dest)
        if d.methods.len == 0 && d.statics.len == 0 {
            self.write(" {}")
            ret
        }
        self.write(" {")
        self.add_indent()
        let (mut si, mut mi, mut statics) = 0, 0, -1
        for {
            let mut s: &ast::VarDecl = nil
            let mut m: &ast::FnDecl = nil
            if si < d.statics.len {
                s = d.statics[si]
            }
            if mi < d.methods.len {
                m = d.methods[mi]
            }
            if s == nil && m == nil {
                break
            }
            if s != nil && (m == nil || s.token.row < m.token.row) {
                if statics == -1 {
                    statics = si
                }
                si++
                continue
            }
            self.write("\n")
            if statics != -1 {
                let mut vars = d.statics[statics:si]
                let mut j = -1
                self.group_decls[&ast::VarDecl, &ast::VarDecl](vars, j)
                statics = -1
                self.write("\n")
            }
            self.write_comments(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.write("\n")
            mi++
        }
        if statics != -1 {
            if mi > 0 || self.buf[self.buf.len - 1] != '\n' {
                self.write("\n")
            }
            let mut vars = d.statics[statics:si]
            let mut j = -1
            self.group_decls[&ast::VarDecl, &ast::VarDecl](vars, j)
        }
        self.add_global_padding_for_comment(d.end.row)
        self.write_comments_except(d.end.row)
        self.done_indent()
        self.write("}")
        self.pop_row_comments(d.end.row)
    }

    fn node(&self, mut &node: ast::Node) {
        match type node.data {
        | &ast::TypeAliasDecl:
            if node.token.row - self.write_comments_except(node.token.row) > 1 {
                self.write("\n")
            }
            self.group_decls[&ast::TypeAliasDecl, ast::Node](self.f.nodes, self.i)
            ret
        | &ast::VarDecl:
            if node.token.row - self.write_comments_except(node.token.row) > 1 {
                self.write("\n")
            }
            self.group_decls[&ast::VarDecl, ast::Node](self.f.nodes, self.i)
            ret
        }
        if node.token.row - self.write_comments(node.token.row) > 1 {
            self.write("\n")
        }
        match type node.data {
        | &ast::EnumDecl:
            self.enum_decl((&ast::EnumDecl)(node.data))
        | &ast::FnDecl:
            self.fn_decl((&ast::FnDecl)(node.data))
        | &ast::StructDecl:
            self.struct_decl((&ast::StructDecl)(node.data))
        | &ast::TraitDecl:
            self.trait_decl((&ast::TraitDecl)(node.data))
        | &ast::Impl:
            self.impl_decl((&ast::Impl)(node.data))
        }
    }

    fn nodes(&self) {
        self.i = 0
        self.row = 0
        for self.i < self.f.nodes.len; self.i++ {
            let mut node = self.f.nodes[self.i]
            let old = self.i
            if node.token.row - self.row < 2 {
                self.write("\n")
            } else {
                self.write("\n\n")
            }
            self.node(node)
            if old != self.i {
                self.i--
                self.buf = self.buf[:self.buf.len - 1] // Remove trailing newline.
            }
        }
        self.write_remaining_comments()
    }

    fn format(&self, mut &f: &Ast, mut &cm: CommentMap): str {
        self.cm = cm
        self.f = f
        self.directives(self.f.top_directives)
        self.use_decls()
        self.nodes()
        self.f = nil
        ret strings::trim(self.buf, " \n\r\v\t")
    }
}

struct TypeFormatter {
    mut fmt: &Formatter
}

impl TypeFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn generics(self, mut g: []&ast::TypeDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for (i, mut t) in g {
            self.format(t.kind)
            if i + 1 < g.len {
                self.write(",")
            }
        }
        self.write("]")
    }

    fn ident(self, mut id: &ast::IdentTypeDecl) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
        self.generics(id.generics)
    }

    fn namespace(self, mut ns: &ast::NamespaceTypeDecl) {
        for _, id in ns.idents {
            self.write(id.kind)
            self.write("::")
        }
        self.ident(ns.kind)
    }

    fn sptr(self, mut sptr: &ast::SptrTypeDecl) {
        self.write("&")
        self.format(sptr.elem.kind)
    }

    fn slc(self, mut slc: &ast::SlcTypeDecl) {
        self.write("[]")
        self.format(slc.elem.kind)
    }

    fn ptr(self, mut ptr: &ast::PtrTypeDecl) {
        self.write("*")
        if ptr.is_unsafe() {
            self.write("unsafe")
            ret
        }
        self.format(ptr.elem.kind)
    }

    fn arr(self, mut arr: &ast::ArrTypeDecl) {
        self.write("[")
        if arr.auto_sized() {
            self.write("...")
        } else {
            self.fmt.format_expr(arr.size)
        }
        self.write("]")
        self.format(arr.elem.kind)
    }

    fn map(self, mut map: &ast::MapTypeDecl) {
        self.write("[")
        self.format(map.key.kind)
        self.write(":")
        self.format(map.val.kind)
        self.write("]")
    }

    fn format(self, mut &kind: any) {
        match type kind {
        | &ast::IdentTypeDecl:
            self.ident((&ast::IdentTypeDecl)(kind))
        | &ast::NamespaceTypeDecl:
            self.namespace((&ast::NamespaceTypeDecl)(kind))
        | &ast::SptrTypeDecl:
            self.sptr((&ast::SptrTypeDecl)(kind))
        | &ast::SlcTypeDecl:
            self.slc((&ast::SlcTypeDecl)(kind))
        | &ast::PtrTypeDecl:
            self.ptr((&ast::PtrTypeDecl)(kind))
        | &ast::ArrTypeDecl:
            self.arr((&ast::ArrTypeDecl)(kind))
        | &ast::MapTypeDecl:
            self.map((&ast::MapTypeDecl)(kind))
        }
    }
}

struct ScopeFormatter {
    mut fmt: &Formatter
}

impl ScopeFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn usexpr(self, mut u: &ast::UseExpr) {
        self.write("use ")
        self.fmt.format_expr(u.expr)
    }

    fn co_expr(self, mut expr: &ast::CoExpr) {
        self.write("co ")
        self.fmt.format_expr(expr.expr)
    }

    fn label(self, l: &ast::LabelSt) {
        // Remove one indentation.
        self.fmt.buf = self.fmt.buf[:self.fmt.buf.len - self.fmt.indent_len]
        self.write(l.ident)
        self.write(":")
    }

    fn goto_st(self, g: &ast::GotoSt) {
        self.write("goto ")
        self.write(g.label.kind)
    }

    fn fall_st(self, fll: &ast::FallSt) {
        self.write("fall")
    }

    fn cont_st(self, cont: &ast::ContSt) {
        self.write("continue")
        if cont.label.kind != "" {
            self.write(" ")
            self.write(cont.label.kind)
        }
    }

    fn break_st(self, brk: &ast::BreakSt) {
        self.write("break")
        if brk.label.kind != "" {
            self.write(" ")
            self.write(brk.label.kind)
        }
    }

    fn ret_st(self, mut r: &ast::RetSt) {
        self.write("ret")
        if r.expr != nil {
            self.write(" ")
            self.fmt.format_expr(r.expr)
        }
    }

    fn iter(self, mut it: &ast::Iter) {
        self.write("for")
        if !it.is_inf() {
            match type it.kind {
            | &ast::WhileKind:
                self.write(" ")
                let mut wk = (&ast::WhileKind)(it.kind)
                self.fmt.format_expr(wk.expr)
            | &ast::RangeKind:
                self.write(" ")
                let mut rk = (&ast::RangeKind)(it.kind)
                let p = (rk.key_a != nil && rk.key_a.mutable) || (rk.key_b != nil && rk.key_b.mutable)
                if p {
                    self.write("(")
                }
                if rk.key_a != nil {
                    if rk.key_a.mutable {
                        self.write("mut ")
                    }
                    self.write(rk.key_a.ident)
                }
                if rk.key_b != nil {
                    self.write(", ")
                    if rk.key_b.mutable {
                        self.write("mut ")
                    }
                    self.write(rk.key_b.ident)
                }
                if p {
                    self.write(")")
                }
                self.write(" in ")
                self.fmt.format_expr(rk.expr)
            }
        }
        self.write(" ")
        self.format(it.scope)
    }

    fn conditional_case(self, mut c: &ast::If) {
        self.write("if ")
        self.fmt.format_expr(c.expr)
        self.write(" {\n")
        if c.scope.stmts.len > 0 {
            self.fmt.add_indent()
            self.format_stmts(c.scope)
            self.fmt.done_indent()
        }
        self.write(self.fmt.indent)
        self.write("}")
    }

    fn conditional(self, mut c: &ast::Conditional) {
        self.conditional_case(c.head)
        for (_, mut t) in c.tail {
            self.write(" else ")
            self.conditional_case(t)
        }
        if c.default != nil {
            self.write(" else {\n")
            if c.default.scope.stmts.len > 0 {
                self.fmt.add_indent()
                self.format_stmts(c.default.scope)
                self.fmt.done_indent()
            }
            self.write(self.fmt.indent)
            self.write("}")
        }
    }

    fn match_case(self, mut mc: &ast::MatchCase) {
        self.write("match ")
        if mc.type_match {
            self.write("type ")
        }
        if mc.expr != nil {
            self.fmt.format_expr(mc.expr)
            self.write(" ")
        }
        self.write("{\n")
        for (_, mut c) in mc.cases {
            let mut row = c.exprs[0].token.row
            for (i, mut expr) in c.exprs {
                if row != expr.token.row {
                    self.fmt.pop_row_comments(row)
                }
                self.fmt.write_comments_except(expr.token.row)
                if row != expr.token.row {
                    self.write("\n")
                    self.write(self.fmt.indent)
                } else if i == 0 {
                    self.write(self.fmt.indent)
                } else if i > 0 {
                    self.write(" ")
                }
                row = expr.token.row
                self.write("| ")
                self.fmt.format_expr(expr)
            }
            self.write(":")
            self.fmt.pop_row_comments(row)
            self.write("\n")
            self.fmt.add_indent()
            self.format_stmts(c.scope)
            self.fmt.done_indent()
        }
        if mc.default != nil {
            self.write(self.fmt.indent)
            self.write("|:\n")
            self.fmt.add_indent()
            self.format_stmts(mc.default.scope)
            self.fmt.done_indent()
        }
        self.write(self.fmt.indent)
        self.fmt.row = mc.end.row
        self.write("}")
    }

    fn postfix(self, mut &a: &ast::AssignSt) {
        let mut expr = a.left[0].expr
        self.fmt.format_expr(expr)
        self.write(a.setter.kind)
    }

    fn single_assign(self, mut &a: &ast::AssignSt) {
        if lex::is_ignore_ident(a.left[0].ident) {
            self.write("_ ")
        } else {
            let mut expr = a.left[0].expr
            self.fmt.format_expr(expr)
            self.write(" ")
        }
        self.write(a.setter.kind)
        self.write(" ")
        self.fmt.format_expr(a.right)
    }

    fn multi_assign(self, mut &a: &ast::AssignSt) {
        self.write("let (")
        for (i, mut l) in a.left {
            if l.ident != "" {
                if l.mutable {
                    self.write("mut ")
                }
                if l.reference {
                    self.write("&")
                }
                self.write(l.ident)
            } else {
                // Do not write range parentheses.
                // Expression formatter will add.
                self.fmt.format_expr(l.expr)
            }
            if i + 1 < a.left.len {
                self.write(", ")
            }
        }
        self.write(") = ")
        self.fmt.format_expr(a.right)
    }

    fn assign(self, mut a: &ast::AssignSt) {
        match {
        | lex::is_postfix_op(a.setter.kind):
            self.postfix(a)
        | a.left.len == 1 && !a.declarative:
            self.single_assign(a)
        |:
            self.multi_assign(a)
        }
    }

    fn format_stmt(self, mut &stmt: ast::NodeData) {
        match type stmt {
        | &ast::ScopeTree:
            self.format((&ast::ScopeTree)(stmt))
        | &ast::Expr:
            let mut expr = (&ast::Expr)(stmt)
            self.fmt.format_expr(expr)
        | &ast::CoExpr:
            self.co_expr((&ast::CoExpr)(stmt))
        | &ast::LabelSt:
            self.label((&ast::LabelSt)(stmt))
        | &ast::GotoSt:
            self.goto_st((&ast::GotoSt)(stmt))
        | &ast::UseExpr:
            self.usexpr((&ast::UseExpr)(stmt))
        | &ast::FallSt:
            self.fall_st((&ast::FallSt)(stmt))
        | &ast::ContSt:
            self.cont_st((&ast::ContSt)(stmt))
        | &ast::BreakSt:
            self.break_st((&ast::BreakSt)(stmt))
        | &ast::RetSt:
            self.ret_st((&ast::RetSt)(stmt))
        | &ast::Iter:
            self.iter((&ast::Iter)(stmt))
        | &ast::Conditional:
            self.conditional((&ast::Conditional)(stmt))
        | &ast::MatchCase:
            self.match_case((&ast::MatchCase)(stmt))
        | &ast::AssignSt:
            self.assign((&ast::AssignSt)(stmt))
        }
    }

    fn format_stmts(self, mut &scope: &ast::ScopeTree) {
        defer {
            self.fmt.row = scope.end.row
        }
        if scope.stmts.len == 0 {
            ret
        }
        let mut i = 0
        self.fmt.row = scope.stmts[0].token.row
        let mut old = i
        for i < scope.stmts.len; i++ {
            let mut stmt = scope.stmts[i]
            if stmt.token.row - self.fmt.row > 1 {
                self.write("\n\n")
            } else if i > 0 {
                self.write("\n")
            }
            old = i
            self.fmt.row = stmt.token.row
            match type stmt.data {
            | &ast::TypeAliasDecl:
                self.fmt.group_decls[&ast::TypeAliasDecl, ast::Node](scope.stmts, i)
            | &ast::VarDecl:
                self.fmt.group_decls[&ast::VarDecl, ast::Node](scope.stmts, i)
            |:
                self.fmt.write_comments_except(stmt.token.row)
                self.write(self.fmt.indent)
                self.format_stmt(stmt.data)
                self.fmt.pop_row_comments(stmt.token.row)
            }
            if old != i {
                i--
                self.fmt.buf = self.fmt.buf[:self.fmt.buf.len - 1]
            }
        }
        i = self.fmt.buf.len - 1
        for i >= 0; i-- {
            if self.fmt.buf[i] != '\n' {
                self.fmt.buf = self.fmt.buf[:i + 1]
                self.write("\n")
                break
            }
        }
    }

    fn format(self, mut scope: &ast::ScopeTree) {
        if scope.unsafety {
            self.write("unsafe ")
        }
        if scope.deferred {
            self.write("defer ")
        }
        self.write("{\n")
        let n = self.fmt.buf.len
        self.fmt.add_indent()
        self.format_stmts(scope)

        self.fmt.write_comments_except(scope.end.row)

        self.fmt.done_indent()

        if n == self.fmt.buf.len {
            self.fmt.buf = self.fmt.buf[:n - 1]
        } else {
            self.write(self.fmt.indent)
        }

        self.write("}")
        self.fmt.pop_row_comments(scope.end.row)
    }
}

struct ExprFormatter {
    mut fmt: &Formatter
}

impl ExprFormatter {
    fn write(&self, s: str) {
        self.fmt.buf += s
    }

    fn tuple(&self, mut tup: &ast::TupleExpr) {
        for (i, mut expr) in tup.expr {
            self.format(expr)
            if i + 1 < tup.expr.len {
                self.write(", ")
            }
        }
    }

    fn lit(&self, l: &ast::LitExpr) {
        self.write(l.value)
    }

    fn unsafexpr(&self, mut u: &ast::UnsafeExpr) {
        self.write("unsafe { ")
        self.format(u.expr)
        self.write(" }")
    }

    fn coexpr(&self, mut c: &ast::CoExpr) {
        self.write("co ")
        self.format(c.expr)
    }

    fn ident(&self, id: &ast::IdentExpr) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
    }

    fn unary(&self, mut u: &ast::UnaryExpr) {
        self.write(u.op.kind)
        self.format(u.expr)
    }

    fn variadic(&self, mut v: &ast::VariadicExpr) {
        self.format(v.expr)
        self.write("...")
    }

    fn cast(&self, mut c: &ast::CastExpr) {
        self.write("(")
        self.fmt.format_type(c.kind)
        self.write(")")
        self.write("(")
        self.format(c.expr)
        self.write(")")
    }

    fn nselect(&self, ns: &ast::NsSelectionExpr) {
        for _, s in ns.ns {
            self.write(s.kind)
            self.write("::")
        }
        self.write(ns.ident.kind)
    }

    fn sub_ident(&self, mut si: &ast::SubIdentExpr) {
        self.format(si.expr)
        self.write(".")
        self.write(si.ident.kind)
    }

    fn binary(&self, mut bin: &ast::BinopExpr) {
        self.fmt.pop_row_comments_by_c(bin.left.token.row, bin.left.token.column)
        self.format(bin.left)
        self.write(" ")
        self.fmt.pop_row_comments_by_c(bin.op.row, bin.op.column)
        self.write(bin.op.kind)
    rep:
        if bin.op.row == bin.right.token.row {
            self.write(" ")
            self.fmt.pop_row_comments_by_c(bin.right.token.row, bin.right.token.column)
            self.format(bin.right)
            ret
        }
        self.fmt.add_indent()
        self.fmt.pop_row_comments_by(bin.op.row)
        self.write("\n")
        self.write(self.fmt.indent)
        self.fmt.pop_row_comments_by_c(bin.right.token.row, bin.right.token.column)
        match type bin.right.kind {
        | &ast::BinopExpr:
            bin = (&ast::BinopExpr)(bin.right.kind)
            self.fmt.pop_row_comments_by_c(bin.left.token.row, bin.left.token.column)
            self.format(bin.left)
            self.write(" ")
            self.fmt.pop_row_comments_by_c(bin.left.token.row, bin.left.token.column)
            self.fmt.pop_row_comments_by_c(bin.op.row, bin.op.column)
            self.write(bin.op.kind)
            self.fmt.pop_row_comments(bin.op.row)
            self.fmt.done_indent()
            goto rep
        |:
            self.fmt.pop_row_comments_by_c(bin.right.token.row, bin.right.token.column)
            self.format(bin.right)
            self.fmt.row = bin.right.token.row
        }
        self.fmt.done_indent()
    }

    fn args(&self, mut &args: []&ast::Expr) {
        if args.len == 0 {
            ret
        }
        let mut row = args[0].token.row
        let mut indented = false
        for (i, mut arg) in args {
            if i > 0 {
                self.write(",")
            }
            if row != arg.token.row {
                if !indented {
                    indented = true
                    self.fmt.add_indent()
                }
                self.fmt.pop_row_comments(self.fmt.row)
                self.write("\n")
                self.write(self.fmt.indent)
            } else if i > 0 {
                self.write(" ")
            }
            self.fmt.pop_row_comments_by_c(arg.token.row, arg.token.column)
            self.format(arg)
            self.fmt.pop_row_comments_by_c(arg.token.row, arg.token.column)
            row = self.fmt.row
        }
        if indented {
            self.fmt.done_indent()
        }
    }

    fn fn_call(&self, mut f: &ast::FnCallExpr) {
        self.format(f.expr)
        let tf = TypeFormatter{
            fmt: self.fmt,
        }
        tf.generics(f.generics)
        self.write("(")
        self.args(f.args)
        self.write(")")
        if f.args.len > 0 {
            self.fmt.pop_row_comments(f.args[f.args.len - 1].token.row)
        }
        if f.ignored() {
            self.write("!")
        } else if f.exception != nil {
            self.write(" else ")
            self.fmt.format_scope(f.exception)
            self.fmt.row = f.exception.end.row
        }
    }

    fn field_expr_pair(&self, mut pair: &ast::FieldExprPair) {
        if pair.is_targeted() {
            self.write(pair.field.kind)
            self.write(": ")
        }
        self.format(pair.expr)
    }

    fn struct_lit(&self, mut lit: &ast::StructLit) {
        self.fmt.format_type(lit.kind)
        if lit.exprs.len == 0 {
            self.write("{}")
            ret
        }
        let mut newline = false
        for _, expr in lit.exprs {
            // Compare with kind row. Because kind and brace should be same line.
            // Therefore, kind row also means brace row.
            if expr.token.row != lit.kind.token.row {
                newline = true
                break
            }
        }
        self.write("{")
        if newline {
            self.write("\n")
        }
        self.fmt.add_indent()
        for (i, mut expr) in lit.exprs {
            let diff = lit.exprs.len - i
            if newline {
                self.write(self.fmt.indent)
            }
            self.fmt.pop_row_comments_by_c(expr.token.row, expr.token.column)
            self.format(expr)
            self.fmt.pop_row_comments_by_c(expr.token.row, expr.token.column)
            if newline {
                self.write(",")
                if diff < 2 || lit.exprs[i + 1].token.row != self.fmt.row {
                    self.fmt.pop_row_comments(self.fmt.row)
                }
                self.write("\n")
            } else if diff > 1 {
                self.write(", ")
            }
        }
        self.fmt.done_indent()
        if newline {
            self.write(self.fmt.indent)
        }
        self.write("}")
    }

    fn responsive_exprs[T](&self, mut &lit: T) {
        const CAP = 1 << 8
        let mut exprs = make([]str, 0, CAP)
        let mut rows = make([]RowAlign, 0, CAP)

        let n = self.fmt.buf.len
        let mut max = 0
        let mut row = lit.token.row
        let mut lined = false

        self.fmt.add_indent()
        for (i, mut expr) in lit.exprs {
            if row != expr.token.row {
                lined = true
                let diff = self.fmt.buf.len - n
                if diff > 0 {
                    if max < diff && self.fmt.row == row {
                        max = diff
                    }
                    exprs = append(exprs, self.fmt.buf[n:])
                    self.fmt.buf = self.fmt.buf[:n]
                    rows = append(rows, RowAlign{
                        row: self.fmt.row,
                        max: self.fmt.row == row,
                    })
                }
            } else if i > 0 {
                self.write(" ")
            }
            self.fmt.pop_row_comments_by_c(expr.token.row, expr.token.column)
            self.format(expr)
            self.fmt.pop_row_comments_by_c(expr.token.row, expr.token.column)
            row = expr.token.row
            if lined || lit.exprs.len - i > 1 {
                self.write(",")
            }
        }
        if n != self.fmt.buf.len {
            let diff = self.fmt.buf.len - n
            if max < diff && self.fmt.row == row {
                max = diff
            }
            exprs = append(exprs, self.fmt.buf[n:])
            rows = append(rows, RowAlign{
                row: self.fmt.row,
                max: self.fmt.row == row,
            })
            self.fmt.buf = self.fmt.buf[:n]
        }

        if lit.token.row != lit.exprs[0].token.row {
            self.write("\n")
            self.write(self.fmt.indent)
        }
        for i, expr in exprs {
            let erow = rows[i]
            self.write(expr)
            for {
                let c = self.fmt.cm.pop(erow.row)
                if c == nil {
                    break
                }
                if erow.max {
                    self.write(strings::repeat(" ", padding_abs(max - expr.len) + 1))
                } else {
                    self.write(" ")
                }
                self.fmt.write_comment(c)
            }
            if exprs.len - i > 1 {
                self.write("\n")
                self.write(self.fmt.indent)
            }
        }
        self.fmt.done_indent()
        if self.fmt.buf[self.fmt.buf.len - 1] == '\n' {
            self.write(self.fmt.indent)
        } else if lined {
            self.write("\n")
            self.write(self.fmt.indent)
        }
    }

    fn brace_lit(&self, mut lit: &ast::BraceLit) {
        self.write("{")
        self.responsive_exprs[&ast::BraceLit](lit)
        self.write("}")
        self.fmt.pop_row_comments(lit.token.row)
    }

    fn key_val_pair(&self, mut pair: &ast::KeyValPair) {
        self.format(pair.key)
        self.write(": ")
        self.format(pair.val)
    }

    fn slice(&self, mut s: &ast::SliceExpr) {
        self.write("[")
        self.responsive_exprs[&ast::SliceExpr](s)
        self.write("]")
        self.fmt.pop_row_comments(s.token.row)
    }

    fn indexing(&self, mut i: &ast::IndexingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.index)
        self.write("]")
    }

    fn slicing(&self, mut i: &ast::SlicingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.start)
        self.write(":")
        self.format(i.to)
        self.write("]")
    }

    fn ternary(&self, mut t: &ast::TernaryExpr) {
        self.write("if ")
        self.format(t.condition)
        self.write(" { ")
        self.format(t.true_expr)
        self.write(" } else { ")
        self.format(t.false_expr)
        self.write(" }")
    }

    fn format_kind(&self, mut &kind: any) {
        match type kind {
        | &ast::Expr:
            let mut expr = (&ast::Expr)(kind)
            self.format(expr)
        | &ast::TypeDecl:
            let mut t = (&ast::TypeDecl)(kind)
            self.fmt.format_type(t)
        | &ast::FnDecl:
            self.fmt.fn_decl((&ast::FnDecl)(kind))
        | &ast::IdentExpr:
            self.ident((&ast::IdentExpr)(kind))
        | &ast::TupleExpr:
            self.tuple((&ast::TupleExpr)(kind))
        | &ast::LitExpr:
            self.lit((&ast::LitExpr)(kind))
        | &ast::UnsafeExpr:
            self.unsafexpr((&ast::UnsafeExpr)(kind))
        | &ast::CoExpr:
            self.coexpr((&ast::CoExpr)(kind))
        | &ast::UnaryExpr:
            self.unary((&ast::UnaryExpr)(kind))
        | &ast::VariadicExpr:
            self.variadic((&ast::VariadicExpr)(kind))
        | &ast::CastExpr:
            self.cast((&ast::CastExpr)(kind))
        | &ast::NsSelectionExpr:
            self.nselect((&ast::NsSelectionExpr)(kind))
        | &ast::SubIdentExpr:
            self.sub_ident((&ast::SubIdentExpr)(kind))
        | &ast::BinopExpr:
            self.binary((&ast::BinopExpr)(kind))
        | &ast::FnCallExpr:
            self.fn_call((&ast::FnCallExpr)(kind))
        | &ast::FieldExprPair:
            self.field_expr_pair((&ast::FieldExprPair)(kind))
        | &ast::StructLit:
            self.struct_lit((&ast::StructLit)(kind))
        | &ast::BraceLit:
            self.brace_lit((&ast::BraceLit)(kind))
        | &ast::KeyValPair:
            self.key_val_pair((&ast::KeyValPair)(kind))
        | &ast::SliceExpr:
            self.slice((&ast::SliceExpr)(kind))
        | &ast::IndexingExpr:
            self.indexing((&ast::IndexingExpr)(kind))
        | &ast::SlicingExpr:
            self.slicing((&ast::SlicingExpr)(kind))
        | &ast::TernaryExpr:
            self.ternary((&ast::TernaryExpr)(kind))
        }
    }

    fn format(&self, mut &expr: &ast::Expr) {
        if expr == nil {
            ret
        }
        self.fmt.row = expr.token.row
        if expr.range {
            self.write("(")
        }
        self.format_kind(expr.kind)
        if expr.range {
            self.write(")")
        }
    }
}

fn padding_abs(x: int): int {
    if x < 0 {
        ret 0
    }
    ret x
}
