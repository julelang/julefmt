// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/bytes"
use "std/jule"
use "std/jule/ast"
use "std/jule/token"
use "std/jule/types"
use "std/slices"
use "std/strings"
use "std/unicode/utf8"

struct field {
	f:     &ast::Field
	token: &token::Token
	tag:   []byte
}

struct rowAlign {
	row: int
	end: int
	col: int
	max: bool
}

struct formatter {
	indentLen: int
	indentStr: str

	mut i:          int
	mut buf:        strings::Builder
	mut f:          &ast::AST
	mut atomIndent: str    // Single indentation
	mut indent:     []byte // Whole indentation based on the current indentation level
	mut cm:         commentMap
	mut row:        int

	mut ef: &exprFormatter
	mut sf: &scopeFormatter
}

impl formatter {
	fn new(): &formatter {
		mut fmt := new(formatter)
		fmt.ef = exprFormatter.new(fmt)
		fmt.sf = &scopeFormatter{fmt: fmt}
		fmt.indentLen = 1
		fmt.indentStr = "\t"
		fmt.atomIndent = strings::Repeat(fmt.indentStr, fmt.indentLen)
		ret fmt
	}

	fn ubuf(*self): []byte {
		ret unsafe { self.buf.Buf() }
	}

	fn setBuf(*self, mut b: []byte) {
		unsafe { self.buf.SetBuf(b) }
	}

	fn write(&self, s: str) {
		self.buf.WriteStr(s)!
	}

	fn addIndent(&self) {
		self.indent = append(self.indent, self.atomIndent...)
	}

	fn doneIndent(&self) {
		self.indent = self.indent[:len(self.indent)-self.indentLen]
	}

	// Writes comment and returns adjustment for row.
	// Adding adjustment to the row data gives the row with comment adjusted.
	fn writeComment(&self, c: &comment): (adjustment: int) {
		if len(self.indent) > 0 && c.txt[1] == '*' {
			// Range comment should be checked.
			// Ending is should be padded by indentation.
			mut i := utf8::RuneCountStr(c.txt) - 3
		lookup:
			for i > 1; i-- {
				b := c.txt[i]
				match b {
				| ' ' | '\t' | '\v' | '\r':
					continue
				| '\n':
					cmt := c.txt[:i+1]
					i = bytes::LastIndexByte(self.ubuf(), '\n')
					self.write(cmt)
					self.buf.Write(self.indent)!
					self.write("*/")
					adjustment = strings::Count(cmt, "\n")
					ret
				|:
					break lookup
				}
			}
		}
		if c.txt[1] == '/' {
			// Single-line comment, trim trailing spaces before writing.
			self.write(strings::TrimRight(c.txt, " \t\v\b"))
			ret
		}
		self.write(c.txt)
		ret 0
	}

	fn seekCommentExcept(&self, row: int): &comment {
		for (_, mut c) in self.cm.buf {
			if row != -1 && c.row >= row {
				break
			}
			ret c
		}
		ret nil
	}

	fn writeCommentsExceptL(&self, start: int, row: int, pad: bool): int {
		mut lrow := row
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if start != -1 && c.row < start {
				i++
				continue
			} else if row != -1 && c.row >= row {
				break
			}
			if pad && c.row-lrow > 1 {
				self.write("\n")
			}
			lrow = c.row
			self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
			self.buf.Write(self.indent)!
			self.writeComment(c)
			if c.txt[1] == '*' {
				// If comment is range, it might include new-lines.
				// Count them and add to lrow for correct row calculation.
				lrow += strings::Count(c.txt, "\n")
			}
			self.write("\n")
		}
		ret lrow
	}

	fn writeCommentsExcept(&self, row: int): int {
		const Pad = true
		ret self.writeCommentsExceptL(-1, row, Pad)
	}

	fn writeComments(&self, row: int): int {
		ret self.writeCommentsExcept(row + 1)
	}

	fn addGlobalPaddingForCommentL(&self, start: int, row: int) {
		mut i := 0
		for i < len(self.cm.buf); i++ {
			c := self.cm.buf[i]
			if c.row >= start && c.row <= row {
				if c.row-self.row > 1 {
					self.write("\n")
				}
				break
			}
		}
	}

	// padded: whether padding added
	// tight: whether comment is exist but not spaced
	fn addGlobalPaddingForComment(&self, row: int): (padded: bool, tight: bool) {
		c := self.cm.first(row)
		if c != nil {
			if c.row-self.row > 1 {
				self.write("\n")
				padded = true
				ret
			} else {
				tight = true
			}
		}
		ret
	}

	fn writeRemainingComments(&self) {
		self.addGlobalPaddingForComment(-1)
		self.writeCommentsExcept(-1)
	}

	fn isPopsRowCommentsByF(*self, row: int, col: int): bool {
		mut i := 0
		for i < len(self.cm.buf); i++ {
			c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				ret true
			} else if c.row > row {
				ret false
			}
		}
		ret false
	}

	fn popRowCommentsUntilByF(&self, row: int, col: int, f: fn(mut &comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			mut c := self.cm.buf[i]
			if c.row > row {
				break
			}
			if col == -1 || c.col < col {
				f(c)
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			}
			i++
		}
	}

	fn popRowCommentsByF(&self, row: int, col: int, f: fn(mut &comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			mut c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				f(c)
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			} else if c.row > row {
				break
			}
			i++
		}
	}

	fn popRowCommentsBy(&self, row: int) {
		self.popRowCommentsByF(row, -1, fn(c: &comment) {
			self.write(" ")
			self.writeComment(c)
		})
	}

	fn popRowCommentsByC(&self, row: int, col: int) {
		self.popRowCommentsByF(row, col, fn(c: &comment) {
			self.write(c.txt)
			self.write(" ")
		})
	}

	fn popRowComments(&self, row: int) {
		for {
			c := self.cm.pop(row)
			if c == nil {
				break
			}
			self.write(" ")
			self.writeComment(c)
		}
	}

	fn formatExpr(&self, mut expr: &ast::Expr) {
		self.ef.format(expr)
		self.ef.clean()
	}

	fn formatType(&self, mut expr: &ast::Expr) {
		self.formatExpr(expr)
	}

	fn formatScope(&self, mut scope: &ast::ScopeTree, options: scopeOption) {
		self.sf.format(scope, options)
	}

	fn directive(&self, d: &ast::Directive) {
		self.write("#")
		self.write(d.Tag.Kind)
		for i, arg in d.Args {
			match {
			| i == 0:
				self.write(" ")
			| arg.ID != token::RPAREN &&
				d.Args[i-1].ID != token::LPAREN &&
				d.Args[i-1].ID != token::NOT:
				self.write(" ")
			}
			self.write(arg.Kind)
		}
	}

	fn directives(&self, dvs: []&ast::Directive) {
		if len(dvs) == 0 {
			ret
		}
		first := dvs[0]
		if first.Tag.Row-self.writeCommentsExcept(first.Tag.Row) > 1 {
			self.write("\n")
		}
		for i, d in dvs {
			if i > 0 {
				self.buf.Write(self.indent)!
			}
			self.writeCommentsExcept(d.Tag.Row)
			self.directive(d)
			self.popRowComments(d.Tag.Row)
			self.write("\n")
			self.row = d.Tag.Row
		}
	}

	fn topDirectives(&self, dvs: []&ast::Directive) {
		if len(dvs) == 0 {
			ret
		}
		first := dvs[0]
		self.row = self.writeCommentsExcept(first.Tag.Row)
		for i, d in dvs {
			if i > 0 {
				self.buf.Write(self.indent)!
			}
			padded, tight := self.addGlobalPaddingForComment(d.Tag.Row)
			if !padded {
				if !tight && d.Tag.Row-self.row > 1 {
					self.write("\n")
				}
			}
			self.writeCommentsExcept(d.Tag.Row)
			self.directive(d)
			self.popRowComments(d.Tag.Row)
			self.write("\n")
			self.row = d.Tag.Row
		}
	}

	fn useDecl(&self, d: &ast::Use) {
		if d.Extern {
			self.write("extern ")
		}
		self.write("use ")
		if d.Alias != nil {
			self.write(d.Alias.Kind)
			self.write(" ")
		}
		self.write(d.Path.Kind)
	}

	fn useDecls(&self) {
		if len(self.f.UseDecls) == 0 {
			ret
		}
		if len(self.f.TopDirectives) > 0 {
			self.write("\n\n")
		}

		// Write all-comments first.
		// Do this before ordering use declarations to find correct last comment.
		{
			first := self.f.UseDecls[0]
			self.addGlobalPaddingForComment(first.Token.Row)
			self.row = self.writeComments(first.Token.Row)
			if first.Token.Row-self.row > 1 {
				self.write("\n")
			}
			const Pad = false
			self.writeCommentsExceptL(-1, self.f.UseDecls[len(self.f.UseDecls)-1].Token.Row+1, Pad)
		}

		// Sort imports.
		// See formatter documentation how ordering will be made.
		slices::SortFunc(self.f.UseDecls, fn(a: &ast::Use, b: &ast::Use): int {
			if a.Extern != b.Extern {
				if a.Extern {
					ret +1
				}
				ret -1
			}
			// a.Extern == b.Extern
			if a.Extern {
				ret strings::Compare(a.Path.Kind, b.Path.Kind)
			}
			const StdPrefix = `"std/`
			aStd := strings::HasPrefix(a.Path.Kind, StdPrefix)
			bStd := strings::HasPrefix(b.Path.Kind, StdPrefix)
			if aStd == bStd {
				ret strings::Compare(a.Path.Kind, b.Path.Kind)
			}
			if aStd && !bStd {
				ret +1
			}
			ret -1
		})

		mut _extern := false // whether any external import seen
		for i, decl in self.f.UseDecls {
			if !_extern && decl.Extern {
				_extern = true
				if i > 0 {
					// ordinary import seen
					// separate external imports
					self.write("\n")
				}
			}
			self.row = decl.Token.Row
			self.useDecl(decl)
			if len(self.f.UseDecls)-i > 1 {
				self.write("\n")
			}
		}
	}

	fn generics(&self, mut g: []&ast::Generic) {
		if len(g) == 0 {
			ret
		}
		self.write("[")
		for (i, mut t) in g {
			self.write(t.Name)
			if t.Constraint != nil {
				self.write(": ")
				for (j, mut c) in t.Constraint.Mask {
					if c.Deep {
						self.write("~")
					}
					self.formatType(c.Type)
					if len(t.Constraint.Mask)-j > 1 {
						self.write(" | ")
					}
				}
			}
			if i+1 < len(g) {
				self.write(", ")
			}
		}
		self.write("]")
	}

	fn enumItem[T](&self, mut item: T) {
		const match type T {
		| &ast::EnumItem:
			self.write(item.Name)
			if !item.IsAutoExpr() {
				self.write(": ")
				self.formatExpr(item.X)
			}
		| &ast::TypeEnumItem:
			self.formatType(item.Type)
		}
		self.write(",")
	}

	fn enumDecl[T](&self, mut d: T) {
		self.write("enum ")
		self.write(d.Name)
		const match type T {
		| &ast::Enum:
			if !d.IsDefaultTyped() {
				self.write(": ")
				self.formatType(d.Type)
			}
		| &ast::TypeEnum:
			self.write(": type")
		}
		self.write(" {")
		if len(d.Items) > 0 {
			self.write("\n")
			self.addIndent()
			mut i, mut row := 0, 0
			for i < len(d.Items) {
				old := self.i
				item := d.Items[i]
				const match type T {
				| &ast::Enum:
					self.groupDecls[&ast::EnumItem, &ast::EnumItem](d.Items, &i, fn(mut d: &ast::EnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::EnumItem](d)
					})
				| &ast::TypeEnum:
					self.groupDecls[&ast::TypeEnumItem, &ast::TypeEnumItem](d.Items, &i, fn(mut d: &ast::TypeEnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::TypeEnumItem](d)
					})
				}
				if i < len(d.Items) {
					padded, _ := self.addGlobalPaddingForComment(d.End.Row)
					if !padded && old != i {
						self.write("\n")
					}
				}
				row = item.Token.Row
			}
			self.addGlobalPaddingForComment(d.End.Row)
			self.writeCommentsExcept(d.End.Row)
			self.doneIndent()
		}
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn params(&self, mut f: &ast::Func) {
		short := f.IsShort()
		mut open, mut close := "(", ")"
		if short {
			open, close = "|", "|"
		}
		if len(f.Params) == 0 {
			self.write(open)
			self.write(close)
			ret
		}
		self.write(open)
		mut indented := false
		self.row = f.Token.Row
		for (i, mut p) in f.Params {
			if self.row != p.Token.Row {
				self.write("\n")
				if !indented {
					indented = true
					self.addIndent()
				}
				self.buf.Write(self.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.popRowCommentsByC(p.Token.Row, p.Token.Column)
			if p.Mutable {
				self.write("mut ")
			}
			if short {
				self.write(p.Name)
			} else {
				if p.Reference {
					self.write("&")
				}
				if p.IsSelf() {
					match {
					| p.IsSmartptr():
						self.write("&")
					| p.IsRefptr():
						self.write("*")
					|:
						panic("unreachable")
					}
					self.write("self")
				} else {
					if !jule::IsAnon(p.Name) {
						self.write(p.Name)
						self.write(": ")
					} else if p.Reference {
						self.write("_: ")
					}
					self.popRowCommentsByC(p.Type.Token.Row, p.Type.Token.Column)
					if p.Variadic {
						self.write("...")
					}
					self.formatType(p.Type)
				}
			}
			if i+1 < len(f.Params) {
				self.write(",")
				if f.Params[i+1].Token.Row != p.Token.Row {
					self.popRowCommentsByF(p.Token.Row, -1, fn(c: &comment) {
						self.write(" ")
						self.writeComment(c)
					})
				}
			}
			self.row = p.Token.Row
		}
		if indented {
			self.doneIndent()
		}
		self.write(close)
	}

	fn result(&self, mut r: &ast::RetType) {
		if len(r.Names) == 0 {
			self.formatType(r.Type)
			ret
		}
		if len(r.Names) == 1 {
			if jule::IsAnon(r.Names[0].Kind) {
				self.formatType(r.Type)
				ret
			}
			self.write("(")
			self.write(r.Names[0].Kind)
			self.write(": ")
			self.formatType(r.Type)
			self.write(")")
			ret
		}
		mut types := r.Type.Data.(&ast::TupleExpr).X
		self.write("(")
		for (i, mut t) in types {
			name := r.Names[i]
			if !jule::IsAnon(name.Kind) {
				self.write(name.Kind)
				self.write(": ")
			}
			self.formatType(t)
			if len(types)-i > 1 {
				self.write(", ")
			}
		}
		self.write(")")
	}

	fn fnDecl(&self, mut d: &ast::Func) {
		if !d.IsAnon() {
			self.writeCommentsExcept(d.Token.Row)
			self.buf.Write(self.indent)!
		}
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
			self.buf.Write(self.indent)!
		}
		if d.Extern {
			self.write("extern ")
		}
		if d.Unsafe {
			self.write("unsafe ")
		}
		self.write("fn")
		if !jule::IsAnon(d.Name) {
			self.write(" ")
			self.write(d.Name)
		}
		self.generics(d.Generics)
		self.params(d)
		if d.Exceptional {
			self.write("!")
		}
		if d.Result.Type != nil {
			self.write(": ")
			self.result(d.Result)
		}
		if d.IsShort() && d.Scope.Deferred {
			// one-liner body
			self.write(" ")
			mut e := d.Scope.Stmts[0].Data.(&ast::Expr)
			// Special case: list expressions must be in range for one-line short function literals.
			_, isTuple := e.Data.(&ast::TupleExpr)
			if isTuple {
				self.write("(")
			}
			self.formatExpr(e)
			if isTuple {
				self.write(")")
			}
			self.row = e.End.Row
		} else if d.Scope != nil {
			self.write(" ")
			_unsafe := d.Unsafe
			d.Scope.Unsafe = false // Avoid unsafe keyword beginning of scope.
			self.formatScope(d.Scope, scopeDefault|scopePopByC)
			d.Scope.Unsafe = _unsafe
			self.row = d.Scope.End.Row
			if !d.IsAnon() {
				self.popRowCommentsBy(self.row)
			}
		}
	}

	// Only parses last field.
	// Leading fields used to calculate maximum declaration length of group for padding.
	fn field(&self, mut f: &field, mut fieldMax: int, mut typeMax: int) {
		self.buf.Write(self.indent)!
		if f.f.Mutable {
			self.write("mut ")
			fieldMax -= 4
		}
		self.write(f.f.Name)
		fieldMax -= utf8::RuneCountStr(f.f.Name)
		self.write(": ")
		if fieldMax > 0 {
			self.write(strings::Repeat(" ", fieldMax))
		}
		n := len(self.ubuf())
		self.formatType(f.f.Type)
		typeMax -= utf8::RuneCount(self.ubuf()[n:])
		if len(f.tag) != 0 {
			if typeMax > 0 {
				self.write(strings::Repeat(" ", typeMax))
			}
			self.write(" ")
			self.buf.Write(f.tag)!
		}
	}

	fn fields(&self, mut fields: []&ast::Field) {
		if len(fields) == 0 {
			ret
		}
		mut flds := make([]&field, 0, len(fields))
		for (_, mut f) in fields {
			flds = append(flds, &field{
				f: f,
				token: f.Token,
			})
		}
		mut i := 0
		for i < len(flds) {
			old := i
			self.fieldGroupDecls(flds, &i)
			if old != i {
				if i < len(flds) {
					self.write("\n")
				}
			} else {
				i++
			}
		}
	}

	fn structDecl(&self, mut d: &ast::Struct) {
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
		} else {
			if d.Token.Row-self.writeComments(d.Token.Row) > 1 {
				self.write("\n")
			}
		}
		if d.Extern {
			self.write("extern ")
		}
		self.write("struct ")
		self.write(d.Name)
		self.generics(d.Generics)
		if len(d.Fields) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row)
			ret
		}
		self.write(" {\n")
		self.addIndent()
		self.fields(d.Fields)
		self.addGlobalPaddingForComment(d.End.Row)
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn traitDecl(&self, mut d: &ast::Trait) {
		self.write("trait ")
		self.write(d.Name)
		if len(d.Methods) == 0 && len(d.Inherits) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row)
			ret
		}
		self.write(" {")
		self.addIndent()
		self.row = d.Token.Row
		for (i, mut ih) in d.Inherits {
			self.write("\n")
			if i > 0 && ih.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(ih.Token.Row)
			self.buf.Write(self.indent)!
			self.formatType(ih)
			self.popRowComments(ih.Token.Row)
			self.row = ih.Token.Row
		}
		if len(d.Inherits) > 0 && len(d.Methods) > 0 {
			if d.Methods[0].Token.Row-self.row > 1 {
				self.write("\n")
			}
		}
		for (i, mut m) in d.Methods {
			self.write("\n")
			if i > 0 && m.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(m.Token.Row)
			self.fnDecl(m)
			self.popRowComments(m.Token.Row)
		}
		// Function declaration formatting won't add new-line.
		// So add a new-line to complete "\n\n" if needed.
		// addGlobalPaddingForComment adds one "\n" if needed.
		padded, _ := self.addGlobalPaddingForComment(d.End.Row)
		pad := padded || self.seekCommentExcept(d.End.Row) != nil
		if pad {
			self.write("\n")
		}
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		// If padding enabled, there is comment.
		// So comment writer will write a new-line after comment.
		// Avoid to write a new-line after comments.
		if !pad {
			self.write("\n")
		}
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn typeAliasDecl(&self, mut d: &ast::TypeAlias) {
		if d.Extern {
			self.write("extern ")
		}
		self.write("type ")
		self.write(d.Name)
		self.generics(d.Generics)
		if d.Strict {
			self.write(": ")
		} else {
			self.write(" = ")
		}
		self.formatType(d.Type)
	}

	fn varDecl(&self, mut d: &ast::Var, head: bool, mut counts: [5]int) {
		// Layout of counts.
		mut typeAnnoMax := counts[0]      // maximum name length for type alignment column
		mut nameMax := counts[1]          // maximum name length of the group
		nameMaxHaveType := counts[2] == 1 // whether nameMax owner have type annotation
		mut typeMax := counts[3]          // maximum length of the type annotations
		table := counts[4] == 1           // whether the alignment is like table, column-by-column

		if head {
			if len(d.Directives) != 0 {
				self.directives(d.Directives)
			}
			if d.Extern {
				self.write("extern let ")
			} else {
				if d.Static {
					self.write("let ")
				} else if d.Const {
					self.write("const ")
				} else if d.Op == nil || d.Op.ID == token::ASSIGN {
					self.write("let ")
				}
			}
			if d.Mutable {
				self.write("mut ")
			}
			if d.Reference {
				self.write("&")
			}
		}
		nameLen := utf8::RuneCountStr(d.Name)
		self.write(d.Name)
		self.row = d.Token.Row
		mut typ := 0
		if d.Type != nil {
			self.write(": ")
			// If typeAnnoMax>0, add the missing leading spaces for type annotation.
			if typeAnnoMax > 0 {
				diff := typeAnnoMax - nameLen
				if diff > 0 {
					self.write(strings::Repeat(" ", diff))
				}
			}
			n := len(self.ubuf())
			self.formatType(d.Type)
			typ = utf8::RuneCount(self.ubuf()[n:]) // subtract the runes of type
			self.row = d.Type.Token.Row
		}
		if d.X != nil {
			// If nameMax>0, we have to do alignment.
			if nameMax > 0 {
				// If typeMax>0 and d.Type==nil, we have type alignment.
				// But this variable have not type annotation.
				// Add spaces for the missing ": " part of type annotations.
				if (nameMaxHaveType || table) && typeMax > 0 && d.Type == nil {
					nameMax += 2
				}
				// If the maximum name have not type annotation and this variable have,
				// remove the spaces of the ": " part of type annotations.
				if !nameMaxHaveType && d.Type != nil {
					nameMax -= 2
				}
				// If we have type alignment and this variable have type annotation,
				// add missing trailing spaces to reach maximum type annotation length.
				if typeMax > 0 && d.Type != nil {
					diff := typeMax - typ
					if diff > 0 {
						self.write(strings::Repeat(" ", diff))
					}
					// Remove the added spaces from alignment.
					nameMax -= diff
				}
				// Remove the spaces of type annotation length of this variable.
				nameMax -= typ
				// If type annotation alignemnt exist and this variable have type annotation,
				// remove the spaces of annotation alignment, because type annotation is aligned.
				// Otherwise, remove spaces for name length,
				// there are still missing spaces for type annotations.
				if typeAnnoMax > 0 && d.Type != nil {
					nameMax -= typeAnnoMax
				} else {
					nameMax -= nameLen
				}
				if nameMax > 0 {
					self.write(strings::Repeat(" ", nameMax))
				}
			}
			self.write(" ")
			self.write(d.Op.Kind)
			self.write(" ")
			self.formatExpr(d.X)
			self.row = d.X.End.Row
		}
	}

	fn getMax(*self, lines: [][]byte, rows: []int, comments: [][]&comment): (max: int, n: int) {
		if len(comments[0]) == 0 {
			ret
		}
		max = utf8::RuneCount(lines[0])
		n = 1
		for n < len(lines); n++ {
			if rows[n-1] == rows[n] || len(comments[n]) == 0 {
				break
			}
			diff := utf8::RuneCount(lines[n])
			if max < diff {
				max = diff
			}
		}
		ret
	}

	fn fieldGroupDecls(&self, mut fields: []&field, mut &i: *int) {
		mut lines := make([][]byte, 0, len(fields))
		mut rows := make([]int, 0, len(fields))
		mut comments := make([][]&comment, 0, len(fields))

		mut start := *i
		self.row = -1
		mut fieldMax := 0
		mut typeMax := 0
		mut n := self.buf.Len()
		for *i < len(fields) {
			mut decl := fields[*i]
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && decl.token.Row-rows[(*i-start)-1] > 1 {
				break
			}
			self.row = decl.token.Row
			mut fm := 0
			if decl.f.Mutable {
				fm += len("mut ")
			}
			fm += utf8::RuneCountStr(decl.f.Name)
			self.formatType(decl.f.Type)
			tm := utf8::RuneCount(self.ubuf()[n:])
			self.setBuf(self.ubuf()[:n])
			if row != -1 && decl.token.Row != self.row {
				break
			}
			if decl.f.Tag != nil {
				self.write(decl.f.Tag.Kind)
				decl.tag = cloneBuf(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
			}
			if row != -1 && decl.token.Row != self.row {
				break
			}
			mut rowComments := make([]&comment, 0)
			mut &_rowComments := &rowComments // for closure
			self.popRowCommentsByF(decl.token.Row, -1, fn(mut c: &comment) {
				unsafe { *_rowComments = append(*_rowComments, c) }
			})
			comments = append(comments, rowComments)
			rows = append(rows, decl.token.Row)
			if fm > fieldMax {
				fieldMax = fm
			}
			if tm > typeMax {
				typeMax = tm
			}
			*i++
		}

		mut j := start
		for j < *i; j++ {
			mut f := fields[j]
			self.field(f, fieldMax, typeMax)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			self.setBuf(self.ubuf()[:n])
		}

		n = 0
		mut max := 0
		for k, line in lines {
			row := rows[k]
			self.writeCommentsExcept(row)
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-k < 2 || rows[k] != rows[k+1] {
				if n == 0 {
					max, n = self.getMax(lines[k:], rows[k:], comments[k:])
				}
				if n > 0 {
					for _, c in comments[k] {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					}
					n--
				}
			}
			self.write("\n")
			start++
		}
	}

	fn varSubGroup(&self, mut vars: []&ast::Var, mut &i: *int) {
		// Do not increase the i, because all grouped variables are represented by the root.
		mut lines := make([][]byte, 0, len(vars[*i:]))
		mut rows := make([]int, 0, len(vars[*i:]))
		mut counts := make([][2]int, 0, len(vars[*i:]))
		mut comments := make([][]&comment, 0, len(vars[*i:]))

		start := *i
		mut n := self.buf.Len()

		// Returns maximum length of identifiers for type annotation alignment.
		// j is the current varaible.
		getTypeAnnoMax := fn(mut j: int): (nameMax: int) {
			counts = counts[:unsafe { *i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.Type != nil {
					j--
				} else {
					break
				}
			}
			for j < unsafe { *i }; j++ {
				mut v := vars[j]
				if v.Type != nil {
					name := counts[j-start][0]
					if name > nameMax {
						nameMax = name
					}
				} else {
					break
				}
			}
			ret
		}

		// Returns maximum length of assignment alignment.
		// j is the current varaible
		getAssignMax := fn(mut j: int, mut &typeAnnoMax: *int): (nameMax: int, nameMaxHaveType: int, typeMax: int, table: int) {
			counts = counts[:unsafe { *i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.X != nil || self.isPopsRowCommentsByF(v.Token.Row, -1) {
					j--
				} else {
					break
				}
			}
			mut fullComment := true // whether the all group members have comment
			mut maxPlainName := 0
			mut maxNameWithType := *typeAnnoMax
			for j < unsafe { *i }; j++ {
				mut v := vars[j]
				comment := self.isPopsRowCommentsByF(v.Token.Row, -1)
				if v.X == nil && !comment {
					break
				}
				fullComment = fullComment && comment
				c := counts[j-start]
				t := c[0]
				if maxPlainName < t {
					maxPlainName = t
				}
				if v.Type != nil {
					if maxNameWithType < t {
						maxNameWithType = t
					}
				}
				if c[1] > typeMax {
					typeMax = c[1]
				}
			}
			if fullComment {
				table = 1
				// typeAnnoMax must strore the maximum length of the group for type alignment.
				*typeAnnoMax = maxNameWithType
				if *typeAnnoMax < maxPlainName {
					*typeAnnoMax = maxPlainName
				}
				// add typeMax to maxPlainName for type alignment.
				// Because all the group must be aligned column-by-column.
				maxPlainName += typeMax
			}
			maxNameWithType += typeMax
			maxNameWithType += 2 // add space for ": " part of type annotation
			if maxNameWithType > maxPlainName {
				maxNameWithType -= 2 // remove space for ": " part of type annotation
				nameMax = maxNameWithType
				nameMaxHaveType = 1
			} else {
				nameMax = maxPlainName
				nameMaxHaveType = 0
			}
			ret
		}

		self.row = -1
		for *i < len(vars); *i++ {
			mut v := vars[*i]
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && v.Token.Row-vars[*i-1].Token.Row > 1 {
				break
			}
			self.row = v.Token.Row
			mut name := utf8::RuneCountStr(v.Name)
			mut typ := 0
			if v.Type != nil {
				self.formatType(v.Type)
				typ = utf8::RuneCount(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			if v.X != nil {
				self.formatExpr(v.X)
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			counts = append(counts, [name, typ])
		}
		mut z := start
		for z < *i; z++ {
			mut typeAnnoMax := getTypeAnnoMax(z)
			nameMax, nameMaxHaveType, typeMax, table := getAssignMax(z, &typeAnnoMax)
			self.varDecl(vars[z], false, [typeAnnoMax, nameMax, nameMaxHaveType, typeMax, table])
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
		}

		// Collects comments separately.
		// For line collection, they are needed.
		n = 0
		z = start
		for z < *i; z++ {
			mut rowComments := make([]&comment, 0)
			mut &_rowComments := &rowComments // for closure
			self.popRowCommentsByF(rows[n], -1, fn(mut c: &comment) {
				unsafe { *_rowComments = append(*_rowComments, c) }
			})
			comments = append(comments, rowComments)
			n++
		}

		n = 0
		mut max := 0
		mut rowBreak := indexRowBrake(rows)
		for j, line in lines {
			row := rows[j]
			if j == rowBreak {
				self.write("\n")
				rowBreak = j + indexRowBrake(rows[j:])
			}
			self.writeCommentsExcept(row)
			self.buf.Write(self.indent)!
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:rowBreak], rows[j:rowBreak], comments[j:rowBreak])
				}
				if n > 0 {
					for _, c in comments[j] {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					}
					n--
				}
			}
			self.write("\n")
		}
		self.row = rows[len(rows)-1] + 1 // Add +1 offset for "\n)" suffix.
	}

	fn varGroup(&self, mut root: &ast::Var, mut &i: *int) {
		// Do not increase the i, because all grouped variables are represented by the root.
		self.buf.Write(self.indent)!
		self.write("const (\n")
		self.addIndent()
		mut j := 0
		for j < len(root.Group) {
			old := j
			self.varSubGroup(root.Group, &j)
			if old != j {
				if j < len(root.Group) {
					self.write("\n")
				}
			} else {
				j++
			}
		}
		self.doneIndent()
		self.buf.Write(self.indent)!
		self.write(")")
	}

	fn groupDecls[T, Node](&self, mut nodes: []Node, mut &i: *int, writer: fn(mut d: T)) {
		if len(nodes) == 0 {
			ret
		}

		// If group declaration used, fall-back to special group handling.
		const match type T {
		| &ast::Var:
			const match type Node {
			| &ast::Var:
				if nodes[*i].Group != nil {
					self.varGroup(nodes[*i], i)
					ret
				}
			| ast::Node | ast::Stmt:
				mut v, ok := nodes[*i].Data.(T)
				if ok && v.Group != nil {
					self.varGroup(v, i)
					ret
				}
			}
		| ast::Node | ast::Stmt:
			mut v, ok := nodes[*i].Data.(&ast::Var)
			if ok && v.Group != nil {
				self.varGroup(v, i)
				ret
			}
		}

		const Cap = 1 << 4
		mut lines := make([][]byte, 0, Cap)
		mut rows := make([]int, 0, Cap)
		mut comments := make([][]&comment, 0, Cap)

		all := *i == -1
		if all {
			*i = 0
		}

		self.row = -1
		mut n := self.buf.Len()
	loop:
		for *i < len(nodes) {
			let mut decl: T
			mut row := -1
			const match type Node {
			| &ast::Var:
				if nodes[*i].Group != nil {
					break loop
				}
				fall
			| &ast::EnumItem
			| &ast::TypeEnumItem
			| &ast::Func:
				decl = nodes[*i]
				row = decl.Token.Row
			| ast::Stmt:
				decl = nodes[*i]
				if !isGroupStmt(decl) {
					break loop
				}
				v, ok := decl.Data.(&ast::Var)
				if ok && v.Group != nil {
					break loop
				}
				row = decl.End.Row
			| ast::Node:
				node := nodes[*i]
				match type node.Data {
				| T:
					decl = nodes[*i].Data.(T)
					row = decl.Token.Row
				|:
					break loop
				}
			|:
				panic("groupDecls: unimplemented type")
			}
			if !all && self.row != -1 && row-self.row > 1 {
				break loop
			}
			self.row = row
			writer(decl)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			mut rowComments := make([]&comment, 0)
			mut &_rowComments := &rowComments // for closure
			self.popRowCommentsByF(row, -1, fn(mut c: &comment) {
				unsafe { *_rowComments = append(*_rowComments, c) }
			})
			comments = append(comments, rowComments)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
			*i++
			const match type Node {
			| ast::Stmt:
				if decl.Token.Row != decl.End.Row {
					// break if start row and end row is not same of stmt
					break loop
				}
			}
		}

		n = 0
		mut max := 0
		for j, line in lines {
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:], rows[j:], comments[j:])
				}
				if n > 0 {
					for _, c in comments[j] {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					}
					n--
				}
			}
			self.write("\n")
		}
	}

	fn writeImplNodes[T](&self, mut nodes: []T, writer: fn(mut d: T)) {
		self.write("\n")
		mut j := 0
		for j < len(nodes) {
			self.groupDecls[T, T](nodes, &j, writer)
			if j < len(nodes) {
				self.write("\n")
			}
		}
	}

	fn implDecl(&self, mut d: &ast::Impl) {
		self.write("impl ")
		if d.IsTraitImpl() {
			self.formatType(d.Base)
			self.write(" for ")
		}
		self.formatType(d.Dest)
		if isEmptyImpl(d) {
			self.write(" {}")
			self.popRowComments(d.End.Row)
			ret
		}

		self.write(" {")
		self.addIndent()
		self.writeImplNodes[&ast::Func](d.Methods, fn(mut d: &ast::Func) {
			self.fnDecl(d)
		})
		self.addGlobalPaddingForComment(d.End.Row)
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		self.write("}")
		self.popRowComments(d.End.Row)
	}

	fn groupNode[T](&self, node: ast::Node, writer: fn(mut d: T)) {
		mut row := node.Token.Row
		const match type T {
		| &ast::TypeAlias:
			break
		|:
			data := node.Data.(T)
			if len(data.Directives) > 0 {
				row = data.Directives[0].Tag.Row
			}
		}
		if row-self.writeCommentsExcept(row) > 1 {
			self.write("\n")
		}
		self.groupDecls[T, ast::Node](self.f.Nodes, &self.i, writer)
	}

	fn node(&self, mut node: ast::Node) {
		match type node.Data {
		| &ast::TypeAlias:
			self.groupNode[&ast::TypeAlias](node, fn(mut d: &ast::TypeAlias) {
				self.buf.Write(self.indent)!
				self.typeAliasDecl(d)
			})
			ret
		| &ast::Var:
			self.groupNode[&ast::Var](node, fn(mut d: &ast::Var) {
				self.buf.Write(self.indent)!
				self.varDecl(d, true, [])
			})
			ret
		| &ast::Func:
			self.groupNode[&ast::Func](node, fn(mut d: &ast::Func) {
				self.fnDecl(d)
			})
			ret
		| &ast::Struct:
			self.structDecl(node.Data.(&ast::Struct))
		|:
			// no-op
		}
		mut commentExist := self.cm.find(node.Token.Row) != nil
		if node.Token.Row-self.writeComments(node.Token.Row) > 1 {
			self.write("\n")
		}
		match type node.Data {
		| &ast::Enum:
			self.enumDecl[&ast::Enum](node.Data.(&ast::Enum))
		| &ast::TypeEnum:
			self.enumDecl[&ast::TypeEnum](node.Data.(&ast::TypeEnum))
		| &ast::Trait:
			self.traitDecl(node.Data.(&ast::Trait))
		| &ast::Impl:
			mut imp := node.Data.(&ast::Impl)
			isGroupHeader := !commentExist && isEmptyImpl(imp)
			self.implDecl(imp)
			mut i := self.i
			if !isGroupHeader {
				ret
			}
			self.i++
		lookup:
			for self.i < len(self.f.Nodes); self.i++ {
				node = self.f.Nodes[self.i]
				match type node.Data {
				| &ast::Impl:
					imp = node.Data.(&ast::Impl)
					if !isEmptyImpl(imp) || self.cm.find(node.Token.Row) != nil {
						break lookup
					}
					self.write("\n")
					self.implDecl(imp)
				|:
					break lookup
				}
			}
			if self.i != i {
				// Add newline to be removed by the [nodes] method.
				self.write("\n")
			}
		|:
			// no-op
		}
	}

	fn nodes(&self) {
		self.i = 0
		self.row = 0
		for self.i < len(self.f.Nodes); self.i++ {
			mut node := self.f.Nodes[self.i]
			old := self.i
			self.write("\n\n")
			self.node(node)
			if old != self.i {
				self.i--
				self.setBuf(self.ubuf()[:self.buf.Len()-1]) // Remove trailing newline.
			}
		}
		self.writeRemainingComments()
	}

	fn format(&self, mut f: &ast::AST, mut cm: commentMap): []byte {
		self.cm = cm
		self.f = f
		self.topDirectives(self.f.TopDirectives)
		if len(self.f.TopDirectives) > 0 {
			self.setBuf(self.ubuf()[:self.buf.Len()-1]) // Remove trailing newline.
		}
		self.useDecls()
		self.nodes()
		self.f = nil
		ret bytes::Trim(self.ubuf(), " \f\n\r\v\t")
	}
}

// Option flags for scope formatter.
type scopeOption: int

const scopeDefault = 0 << 0
const scopePopByC = 1 << 0 // Pops last comments by row and column.

struct scopeFormatter {
	mut fmt: &formatter
}

impl scopeFormatter {
	fn write(&self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn usexpr(&self, mut u: &ast::UseExpr) {
		self.write("use ")
		self.fmt.formatExpr(u.X)
	}

	fn label(&self, l: &ast::Label) {
		// Remove one indentation.
		self.fmt.setBuf(self.fmt.ubuf()[:self.fmt.buf.Len()-self.fmt.indentLen])
		self.write(l.Name)
		self.write(":")
	}

	fn gotoSt(&self, g: &ast::Goto) {
		self.write("goto ")
		self.write(g.Label.Kind)
	}

	fn fallSt(&self, fll: &ast::Fall) {
		self.write("fall")
	}

	fn contSt(&self, cont: &ast::Continue) {
		self.write("continue")
		if cont.Label != nil {
			self.write(" ")
			self.write(cont.Label.Kind)
		}
	}

	fn breakSt(&self, brk: &ast::Break) {
		self.write("break")
		if brk.Label != nil {
			self.write(" ")
			self.write(brk.Label.Kind)
		}
	}

	fn retSt(&self, mut r: &ast::Ret) {
		self.write("ret")
		if r.X != nil {
			self.write(" ")
			self.fmt.formatExpr(r.X)
		}
	}

	fn iter(&self, mut it: &ast::Iter) {
		if it.Comptime {
			self.write("const ")
		}
		self.write("for ")
		if !it.IsInfinite() {
			match type it.Kind {
			| &ast::WhileKind:
				mut wk := it.Kind.(&ast::WhileKind)
				if wk.X != nil {
					self.fmt.popRowCommentsByC(wk.X.Token.Row, wk.X.Token.Column)
					self.fmt.formatExpr(wk.X)
				}
				if wk.Next != nil {
					self.write("; ")
					self.formatStmt(wk.Next, scopeDefault)
				}
				self.write(" ")
			| &ast::RangeKind:
				mut rk := it.Kind.(&ast::RangeKind)
				p := (rk.A != nil && rk.A.Mutable) || (rk.B != nil && rk.B.Mutable)
				if p {
					self.write("(")
				}
				if rk.A != nil {
					self.fmt.popRowCommentsByC(rk.A.Token.Row, rk.A.Token.Column)
					if rk.A.Mutable {
						self.write("mut ")
					}
					self.write(rk.A.Name)
				}
				if rk.B != nil {
					self.write(", ")
					self.fmt.popRowCommentsByC(rk.B.Token.Row, rk.B.Token.Column)
					if rk.B.Mutable {
						self.write("mut ")
					}
					self.write(rk.B.Name)
				}
				if p {
					self.write(") ")
				} else if rk.A != nil || rk.B != nil {
					self.write(" ")
				}
				self.fmt.popRowCommentsByC(rk.InToken.Row, rk.InToken.Column)
				self.write("in ")
				self.fmt.popRowCommentsByC(rk.X.Token.Row, rk.X.Token.Column)
				self.fmt.formatExpr(rk.X)
				self.write(" ")
			}
		}
		self.write("{")
		self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
			self.write(" ")
			self.fmt.writeComment(c)
		})
		self.write("\n")
		self.fmt.addIndent()
		self.formatStmts(it.Scope, false)
		self.fmt.doneIndent()
		self.fmt.buf.Write(self.fmt.indent)!
		self.write("}")
	}

	fn conditionalCase(&self, mut c: &ast::If) {
		self.write("if ")
		self.fmt.popRowCommentsByC(c.X.Token.Row, c.X.Token.Column)
		self.fmt.formatExpr(c.X)
		self.write(" {")
		self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
			self.write(" ")
			self.fmt.writeComment(c)
		})
		self.write("\n")
		self.fmt.addIndent()
		self.formatStmts(c.Scope, false)
		self.fmt.doneIndent()
		self.fmt.buf.Write(self.fmt.indent)!
		self.write("}")
	}

	fn conditional(&self, mut c: &ast::Conditional) {
		self.conditionalCase(c.Tail[0])
		for (_, mut t) in c.Tail[1:] {
			self.write(" ")
			self.fmt.popRowCommentsByC(t.X.Token.Row, t.X.Token.Column)
			self.write("else ")
			self.conditionalCase(t)
		}
		if c.Default != nil {
			self.write(" ")
			self.fmt.popRowCommentsByC(c.Default.Token.Row, c.Default.Token.Column)
			self.write("else {")
			self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
				self.write(" ")
				self.fmt.writeComment(c)
			})
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Default.Scope, false)
			self.fmt.doneIndent()
			self.fmt.buf.Write(self.fmt.indent)!
			self.write("}")
		}
	}

	fn matchCase(&self, mut mc: &ast::Match) {
		if mc.Comptime {
			self.write("const ")
		}
		self.write("match ")
		if mc.Type {
			self.write("type ")
		}
		if mc.X != nil {
			self.fmt.popRowCommentsByC(mc.X.Token.Row, mc.X.Token.Column)
			self.fmt.formatExpr(mc.X)
			self.write(" ")
		}
		self.write("{\n")
		for (_, mut c) in mc.Cases {
			mut row := c.Token.Row

			// Write trailing comments of the previous scope.
			self.fmt.addIndent()
			self.fmt.row = self.fmt.writeCommentsExcept(row)
			self.fmt.doneIndent()

			// Respect space between cases.
			if row-self.fmt.row > 1 {
				self.write("\n")
			}
			for (i, mut expr) in c.X {
				if row != expr.Token.Row {
					self.fmt.popRowComments(row)
				}
				self.fmt.writeCommentsExcept(expr.Token.Row)
				if row != expr.Token.Row {
					self.write("\n")
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i == 0 {
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i > 0 {
					self.write(" ")
				}
				row = expr.Token.Row
				self.write("| ")
				self.fmt.formatExpr(expr)
			}
			self.write(":")
			self.fmt.popRowComments(self.fmt.row)
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Scope, false)
			self.fmt.doneIndent()
			self.fmt.row = c.Scope.End.Row
		}
		if mc.Default != nil {
			row := mc.Default.Token.Row

			// Write trailing comments of the previous scope.
			self.fmt.addIndent()
			self.fmt.row = self.fmt.writeCommentsExcept(row)
			self.fmt.doneIndent()

			// Respect space between cases.
			if row-self.fmt.row > 1 {
				self.write("\n")
			}

			self.fmt.buf.Write(self.fmt.indent)!
			self.write("|:\n")
			self.fmt.addIndent()
			self.formatStmts(mc.Default.Scope, false)
			self.fmt.row = mc.Default.Scope.End.Row
			self.fmt.doneIndent()
		}

		// Write remaining comments with indentation if
		// any case exist.
		caseExist := len(mc.Cases) > 0 || mc.Default != nil
		if caseExist {
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(mc.End.Row)
		if caseExist {
			self.fmt.doneIndent()
		}

		self.fmt.buf.Write(self.fmt.indent)!
		self.fmt.row = mc.End.Row
		self.write("}")
	}

	fn selectCase(&self, mut slct: &ast::Select) {
		caseExist := len(slct.Cases) > 0 || slct.Default != nil
		if !caseExist {
			// Empty select.
			self.write("select{}")
			ret
		}
		self.write("select {\n")
		for (_, mut c) in slct.Cases {
			// Write trailing comments of the previous scope.
			self.fmt.addIndent()
			self.fmt.row = self.fmt.writeCommentsExcept(c.Token.Row)
			self.fmt.doneIndent()

			self.fmt.buf.Write(self.fmt.indent)!
			self.write("| ")
			if c.Stmt == nil {
				self.fmt.formatExpr(c.X[0])
			} else {
				self.formatStmt(c.Stmt, scopeDefault)
			}
			self.write(":")
			self.fmt.popRowComments(self.fmt.row)
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Scope, false)
			self.fmt.doneIndent()
			self.fmt.row = c.Scope.End.Row
		}
		if slct.Default != nil {
			self.fmt.buf.Write(self.fmt.indent)!
			self.write("|:\n")
			self.fmt.addIndent()
			self.formatStmts(slct.Default.Scope, false)
			self.fmt.row = slct.Default.Scope.End.Row
			self.fmt.doneIndent()
		}

		// Write remaining comments with indentation if
		// any case exist.
		if caseExist {
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(slct.End.Row)
		if caseExist {
			self.fmt.doneIndent()
		}

		self.fmt.buf.Write(self.fmt.indent)!
		self.fmt.row = slct.End.Row
		self.write("}")
	}

	fn postfix(&self, mut a: &ast::Assign) {
		mut expr := a.X[0].X
		self.fmt.formatExpr(expr)
		self.write(a.Op.Kind)
	}

	fn singleAssign(&self, mut a: &ast::Assign) {
		if jule::IsBlank(a.X[0].Name) {
			self.write("_ ")
		} else {
			mut expr := a.X[0].X
			self.fmt.formatExpr(expr)
			self.write(" ")
		}
		self.write(a.Op.Kind)
		self.write(" ")
		self.fmt.formatExpr(a.Y)
	}

	fn multiAssign(&self, mut a: &ast::Assign) {
		letKwUsed := a.Op.ID == token::ASSIGN
		if a.Decl && letKwUsed {
			self.write("let (")
		}
		for (i, mut l) in a.X {
			if l.Name != "" {
				if l.Mutable {
					self.write("mut ")
				}
				if l.Reference {
					self.write("&")
				}
			}
			// Do not write range parentheses for expression parts.
			// Expression formatter will add.
			self.fmt.formatExpr(l.X)
			if len(a.X)-i > 1 {
				self.write(", ")
			}
		}
		if a.Decl {
			if letKwUsed {
				self.write(") = ")
			} else {
				self.write(" := ")
			}
		} else {
			self.write(" = ")
		}
		zip := self.fmt.ef.bf.zip
		_, isTup := a.Y.Data.(&ast::TupleExpr)
		if isTup {
			self.fmt.ef.bf.zip = len(a.Y.Data.(&ast::TupleExpr).X) > 1
		}
		self.fmt.formatExpr(a.Y)
		self.fmt.ef.bf.zip = zip
	}

	fn assign(&self, mut a: &ast::Assign) {
		match {
		| token::IsPostfix(a.Op.ID):
			self.postfix(a)
		| len(a.X) == 1 && !a.Decl:
			self.singleAssign(a)
		|:
			self.multiAssign(a)
		}
	}

	fn formatStmt(&self, mut stmt: ast::StmtData, options: scopeOption) {
		match type stmt {
		| &ast::Var:
			self.fmt.varDecl(stmt.(&ast::Var), true, [])
		| &ast::TypeAlias:
			self.fmt.typeAliasDecl(stmt.(&ast::TypeAlias))
		| &ast::ScopeTree:
			self.format(stmt.(&ast::ScopeTree), options)
		| &ast::Expr:
			mut expr := stmt.(&ast::Expr)
			self.fmt.formatExpr(expr)
		| &ast::Label:
			self.label(stmt.(&ast::Label))
		| &ast::Goto:
			self.gotoSt(stmt.(&ast::Goto))
		| &ast::UseExpr:
			self.usexpr(stmt.(&ast::UseExpr))
		| &ast::Fall:
			self.fallSt(stmt.(&ast::Fall))
		| &ast::Continue:
			self.contSt(stmt.(&ast::Continue))
		| &ast::Break:
			self.breakSt(stmt.(&ast::Break))
		| &ast::Ret:
			self.retSt(stmt.(&ast::Ret))
		| &ast::Iter:
			self.iter(stmt.(&ast::Iter))
		| &ast::Conditional:
			self.conditional(stmt.(&ast::Conditional))
		| &ast::Match:
			self.matchCase(stmt.(&ast::Match))
		| &ast::Select:
			self.selectCase(stmt.(&ast::Select))
		| &ast::Assign:
			self.assign(stmt.(&ast::Assign))
		}
	}

	fn emptyScope(&self, mut scope: &ast::ScopeTree) {
		// Lookup for first comment.
		c := self.fmt.seekCommentExcept(scope.End.Row)

		// Range comment exist and scope is not indented.
		// Indent scope if indent is true.
		indent := unsafe { self.fmt.buf.Buf()[self.fmt.buf.Len()-1] } != '\n' &&
			c != nil && c.txt[1] == '*'

		if indent {
			self.write("\n")
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(scope.End.Row)
		if indent {
			self.fmt.doneIndent()
			self.fmt.buf.Write(self.fmt.indent)!
		}
	}

	fn formatStmts(&self, mut scope: &ast::ScopeTree, inline: bool) {
		defer {
			self.fmt.row = scope.End.Row
		}

		if len(scope.Stmts) == 0 {
			self.emptyScope(scope)
			ret
		}

		mut i := 0
		self.fmt.row = scope.Stmts[0].Token.Row
		mut z := i
		for i < len(scope.Stmts); i++ {
			mut stmt := scope.Stmts[i]
			if i > 0 {
				self.write("\n")
			}
			z = self.fmt.row
			self.fmt.addGlobalPaddingForComment(stmt.Token.Row - 1) // Use -1 row for avoid inline comments.
			self.fmt.row = self.fmt.writeCommentsExcept(stmt.Token.Row)
			if stmt.Token.Row-self.fmt.row == 0 {
				self.fmt.row = z
			}
			if stmt.Token.Row-self.fmt.row > 1 {
				self.write("\n")
			}
			z = i
			self.fmt.row = stmt.Token.Row
			if !inline && isGroupStmt(stmt) {
				self.fmt.groupDecls[ast::Stmt, ast::Stmt](scope.Stmts, &i, fn(mut d: ast::Stmt) {
					self.fmt.buf.Write(self.fmt.indent)!
					self.formatStmt(d.Data, scopeDefault)
				})
			} else {
				if !inline {
					self.fmt.buf.Write(self.fmt.indent)!
				}
				self.formatStmt(stmt.Data, scopeDefault)
				if !inline {
					self.fmt.popRowComments(self.fmt.row)
				} else {
					self.fmt.popRowCommentsByF(self.fmt.row, scope.End.Column, fn(c: &comment) {
						self.write(" ")
						self.fmt.writeComment(c)
					})
				}
			}
			if z != i {
				i--
				self.fmt.setBuf(self.fmt.ubuf()[:self.fmt.buf.Len()-1])
			}
		}
		i = self.fmt.buf.Len() - 1
		for i >= 0; i-- {
			if self.fmt.ubuf()[i] != '\n' {
				self.fmt.setBuf(self.fmt.ubuf()[:i+1])
				self.write("\n")
				break
			}
		}

		self.fmt.writeCommentsExcept(scope.End.Row)
	}

	fn format(&self, mut scope: &ast::ScopeTree, options: scopeOption) {
		if scope.Unsafe {
			self.write("unsafe ")
		}
		if scope.Deferred {
			self.write("defer ")
		}
		self.write("{")
		n := self.fmt.buf.Len()
		comment := false   // Whether comment written and indented.
		commentWr := false // Whether comment written.
		{
			mut commentPtr := unsafe { (&bool)(&comment) }
			mut commentWrPtr := unsafe { (&bool)(&commentWr) }
			writer := fn(c: &comment) {
				*commentWrPtr = true
				match {
				| c.txt[1] == '/':
					if !*commentPtr {
						self.fmt.addIndent()
					}
					self.write("\n")
					self.fmt.buf.Write(self.fmt.indent)!
					*commentPtr = true
				| c.txt[1] == '*':
					if strings::ContainsRune(c.txt, '\n') {
						if !*commentPtr {
							self.fmt.addIndent()
						}
						self.write("\n")
						self.fmt.buf.Write(self.fmt.indent)!
						*commentPtr = true
						break
					}
					fall
				| !*commentPtr:
					self.write(" ")
				}
				self.fmt.writeComment(c)
			}
			if len(scope.Stmts) > 0 && scope.Stmts[0].Token.Row == scope.End.Row {
				self.fmt.popRowCommentsByF(self.fmt.row, scope.Stmts[0].Token.Column, writer)
			} else if len(scope.Stmts) == 0 {
				self.fmt.row = scope.End.Row
				self.fmt.popRowCommentsUntilByF(self.fmt.row-1, -1, writer)
				self.fmt.popRowCommentsByF(self.fmt.row, scope.End.Column, writer)
			}
			if comment {
				// Comment(s) written with new-line.
				// So we have to convert space-indentation to indented new-line.
				mut buf := self.fmt.ubuf()
				if buf[n] != '\n' {
					buf[n] = '\n'
					buf = slices::Insert(buf, n+1, self.fmt.indent...)
				}
			}
		}
		inline := (len(scope.Stmts) == 0 && !comment) ||
			(len(scope.Stmts) == 1 &&
				self.fmt.row == scope.End.Row &&
				scope.Stmts[0].Token.Row == scope.End.Row)
		if inline {
			if len(scope.Stmts) > 0 || commentWr {
				self.write(" ")
			}
		} else {
			self.write("\n")
			if !comment {
				self.fmt.addIndent()
			}
		}

		// save internal state of binary formatter
		zip := self.fmt.ef.bf.zip
		op := self.fmt.ef.bf.op
		prec := self.fmt.ef.bf.prec

		// reset internal state of binary formatter
		// thus we can use new internal state for anonymous functions or exceptional handlers
		self.fmt.ef.bf.clean()

		self.formatStmts(scope, inline)

		// save internal state of binary formatter
		self.fmt.ef.bf.zip = zip
		self.fmt.ef.bf.op = op
		self.fmt.ef.bf.prec = prec

		if !inline {
			self.fmt.doneIndent()
		}
		if inline {
			if len(scope.Stmts) > 0 {
				self.fmt.ubuf()[self.fmt.buf.Len()-1] = ' '
			}
		} else if n == self.fmt.buf.Len() {
			self.fmt.setBuf(self.fmt.ubuf()[:n-1])
		} else {
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write("}")
		if options&scopePopByC == scopePopByC {
			self.fmt.popRowCommentsByC(scope.End.Row, scope.End.Column)
		} else {
			self.fmt.popRowComments(scope.End.Row)
		}
		self.fmt.row = scope.End.Row
	}
}

struct exprFormatter {
	mut fmt: &formatter
	mut bf:  &binaryFormatter
}

impl exprFormatter {
	fn new(fmt: &formatter): &exprFormatter {
		mut ef := &exprFormatter{
			fmt: unsafe { *(&fmt) },
		}
		ef.bf = &binaryFormatter{
			ef: ef,
		}
		ret ef
	}

	fn write(&self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn clean(&self) {
		self.bf.clean()
	}

	fn tuple(&self, mut tup: &ast::TupleExpr) {
		for (i, mut expr) in tup.X {
			self.format(expr)
			if i+1 < len(tup.X) {
				self.write(", ")
			}
		}
	}

	fn sliceType(&self, mut slc: &ast::SliceType) {
		self.write("[]")
		self.format(slc.Value)
	}

	fn arrayType(&self, mut arr: &ast::ArrayType) {
		self.write("[")
		if arr.IsAutoSized() {
			self.write("...")
		} else {
			self.fmt.formatExpr(arr.Size)
		}
		self.write("]")
		self.format(arr.Value)
	}

	fn mapType(&self, mut m: &ast::MapType) {
		self.write("map[")
		self.format(m.Key)
		self.write("]")
		self.format(m.Value)
	}

	fn chanType(&self, mut c: &ast::ChanType) {
		if c.Dir&(ast::RECV|ast::SEND) == ast::RECV|ast::SEND {
			self.write("chan ")
		} else if c.Dir&ast::RECV == ast::RECV {
			self.write("<-chan ")
		} else {
			self.write("chan<- ")
		}
		self.format(c.Value)
	}

	fn lit(&self, l: &ast::LitExpr) {
		self.write(l.Value)
	}

	fn unsafexpr(&self, mut u: &ast::UnsafeExpr) {
		self.write("unsafe {")
		line := u.X.Token.Row != u.X.End.Row
		if line {
			self.fmt.addIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.format(u.X)
		if line {
			self.fmt.doneIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.write("}")
	}

	fn name(&self, id: &ast::NameExpr) {
		if id.Extern {
			self.write("extern.")
		}
		self.write(id.Name)
	}

	fn unary(&self, mut u: &ast::UnaryExpr) {
		if u.IsUnsafePtr() {
			self.write("*unsafe")
			ret
		}
		self.write(u.Op.Kind)
		self.format(u.X)
	}

	fn variadic(&self, mut v: &ast::VariadicExpr) {
		self.format(v.X)
		self.write("...")
	}

	fn namespace(&self, ns: &ast::NamespaceExpr) {
		self.write(ns.Namespace.Kind)
		self.write("::")
		self.write(ns.Name.Kind)
	}

	fn selector(&self, mut si: &ast::SelectorExpr) {
		self.format(si.X)
		self.write(".")
		if self.fmt.row != si.Name.Row {
			self.fmt.addIndent()
			defer { self.fmt.doneIndent() }
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write(si.Name.Kind)
		self.fmt.row = si.Name.Row
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bf.new(bin)
		self.bf.binary(bin)
	}

	fn args(&self, mut f: &ast::CallExpr) {
		if len(f.Args) == 0 {
			ret
		}

		// Save the indentation for the SubIdentExpr.
		// Arguments should be handled in this indentation.
		// But exceptional call handler scopes must avoid this indentation.
		//
		// Respect this kind of expression:
		//	foo.
		//		Bar().
		//		Baz(
		//			"foo",
		//			"bar",
		//			"baz") else {
		//		println("error handling...")
		//	}
		sie, _ := f.Func.Data.(&ast::SelectorExpr)
		if sie != nil && sie.X.Token.Row != sie.Name.Row {
			self.fmt.addIndent()
			defer { self.fmt.doneIndent() }
		}

		// save state of zip mode
		zip := self.bf.zip
		self.bf.zip = self.bf.zip || len(f.Args) > 1 // enable zip mode if arguments more than one

		mut row := self.fmt.row
		mut indented := false
		for (i, mut arg) in f.Args {
			if i > 0 {
				self.write(",")
			}
			if row != arg.Token.Row {
				if !indented {
					indented = true
					self.fmt.addIndent()
				}
				const Pad = true
				self.fmt.writeCommentsExceptL(arg.Token.Row, arg.Token.Row, Pad)
				self.write("\n")
				self.fmt.buf.Write(self.fmt.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column)
			self.format(arg)
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column)
			row = self.fmt.row
		}
		if indented {
			self.fmt.doneIndent()
		}

		// save zip mode
		self.bf.zip = zip
	}

	fn call(&self, mut f: &ast::CallExpr) {
		self.fmt.row = f.Token.Row
		if f.IsCo {
			self.write("co ")
		}
		parent := isParentNeededForCall(f.Func)
		if parent {
			self.write("(")
		}
		self.format(f.Func)
		if parent {
			self.write(")")
		}
		self.write("(")
		self.args(f)
		self.write(")")
		match f.Exception {
		| nil:
			// no-op
		| ast::Ignored:
			self.write("!")
		| ast::Forwarded:
			self.write("?")
		|:
			self.write(" else ")
			self.fmt.formatScope(f.Exception, scopeDefault)
			self.fmt.row = f.Exception.End.Row
		}
	}

	fn typedBraceLit(&self, mut lit: &ast::TypedBraceLit) {
		self.fmt.formatType(lit.Type)
		if len(lit.Lit.X) == 0 {
			self.write("{}")
			self.fmt.row = lit.Lit.End.Row
			ret
		}
		mut newline := false
		for _, expr in lit.Lit.X {
			// Compare with kind row. Because kind and brace should be same line.
			// Therefore, kind row also means brace row.
			if expr.Token.Row != lit.Type.Token.Row {
				newline = true
				break
			}
		}
		self.write("{")
		if newline {
			self.write("\n")
		}
		self.fmt.addIndent()
		for (i, mut expr) in lit.Lit.X {
			diff := len(lit.Lit.X) - i
			if newline {
				self.fmt.addGlobalPaddingForComment(expr.Token.Row)
				const Pad = true
				self.fmt.writeCommentsExceptL(self.fmt.row, expr.Token.Row, Pad)
				self.fmt.buf.Write(self.fmt.indent)!
			}
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)
			self.format(expr)
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)
			if newline {
				self.write(",")
				if diff < 2 || lit.Lit.X[i+1].Token.Row != self.fmt.row {
					self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
						self.write(" ")
						self.fmt.writeComment(c)
					})
				}
				self.write("\n")
			} else if diff > 1 {
				self.write(", ")
			}
		}
		self.fmt.addGlobalPaddingForComment(lit.Lit.End.Row)
		const Pad = true
		self.fmt.writeCommentsExceptL(lit.Lit.End.Row, lit.Lit.End.Row, Pad)
		self.fmt.doneIndent()
		if newline {
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write("}")
		self.fmt.row = lit.Lit.End.Row
	}

	fn getMax(*self, lines: [][]byte, rows: []rowAlign, comments: [][]&comment): (max: int, n: int) {
		if len(comments) == 0 || len(comments[0]) == 0 {
			ret
		}
		max = utf8::RuneCount(lines[0])
		n = 1
		for n < len(lines); n++ {
			if rows[n-1].row == rows[n].row || len(comments[n]) == 0 {
				break
			}
			diff := utf8::RuneCount(lines[n])
			if max < diff {
				max = diff
			}
			if rows[n].row-rows[n-1].row > 1 {
				break
			}
		}
		ret
	}

	fn responsiveExprs[T](&self, mut lit: T) {
		if len(lit.X) == 0 {
			ret
		}
		mut exprs := make([][]byte, 0)
		mut rows := make([]rowAlign, 0)
		mut leadingComments := make([]&comment, 0)
		mut trailingComments := make([][]&comment, 0)

		mut n := self.fmt.buf.Len()
		mut max := 0
		mut col := 0
		mut row := lit.Token.Row
		mut endRow := lit.Token.Row
		mut lined := false

		for (_, mut expr) in lit.X {
			if row != expr.Token.Row {
				lined = true
				break
			}
			row = expr.Token.Row
		}

		self.fmt.addIndent()
		for (i, mut expr) in lit.X {
			if i > 0 && row != expr.Token.Row {
				// Collect trailing comments inline for whole row.
				mut rowComments := make([]&comment, 0)
				mut &_rowComments := &rowComments // for closure
				mut col2 := col
				if lined {
					col2 = -1
				}
				self.fmt.popRowCommentsByF(endRow, col2, fn(mut c: &comment) {
					unsafe { *_rowComments = append(*_rowComments, c) }
				})
				trailingComments = append(trailingComments, rowComments)

				mut line := cloneBuf(self.fmt.ubuf()[n:])
				diff := utf8::RuneCount(line)
				if diff > 0 {
					if max < diff && self.fmt.row == row {
						max = diff
					}
					exprs = append(exprs, line)
					self.fmt.setBuf(self.fmt.ubuf()[:n])
					rows = append(rows, rowAlign{
						end: self.fmt.row,
						row: row,
						col: col,
						max: self.fmt.row == row,
					})
				}
			} else if i > 0 {
				self.write(" ")
			}

			// Collect leading comments, except inline.
			// Use [expr.Token.Row-1] to exclude the row of the current expression.
			mut &_leadingComments := &leadingComments // for closure
			self.fmt.popRowCommentsUntilByF(expr.Token.Row-1, -1, fn(mut c: &comment) {
				unsafe { *_leadingComments = append(*_leadingComments, c) }
			})

			// Write leading inline row comments before expression.
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)

			self.format(expr)

			row = expr.Token.Row
			endRow = expr.End.Row
			col = expr.End.Column
			if lined || len(lit.X)-i > 1 {
				self.write(",")
			}
		}
		if n != self.fmt.buf.Len() {
			// Collect trailing comments inline for whole row.
			mut rowComments := make([]&comment, 0)
			mut &_rowComments := &rowComments // for closure
			mut col2 := col
			if lined {
				col2 = -1
			}
			self.fmt.popRowCommentsByF(endRow, col2, fn(mut c: &comment) {
				unsafe { *_rowComments = append(*_rowComments, c) }
			})
			trailingComments = append(trailingComments, rowComments)

			mut line := cloneBuf(self.fmt.ubuf()[n:])
			diff := utf8::RuneCount(line)
			if max < diff && self.fmt.row == row {
				max = diff
			}
			exprs = append(exprs, line)
			rows = append(rows, rowAlign{
				end: self.fmt.row,
				row: row,
				col: col,
				max: self.fmt.row == row,
			})
			self.fmt.setBuf(self.fmt.ubuf()[:n])
		}

		fmtRow := self.fmt.row
		defer {
			self.fmt.row = fmtRow
		}
		if lit.Token.Row != lit.X[0].Token.Row {
			self.write("\n")
		}
		self.fmt.row = lit.Token.Row
		n = 0
		max = 0
		for i, expr in exprs {
			erow := rows[i]

			// Write leading comments.
			mut j := 0
			for j < len(leadingComments); j++ {
				c := leadingComments[j]
				if c.row <= erow.row {
					// Respect space between cases.
					if c.row-self.fmt.row > 1 {
						self.write("\n")
						self.fmt.buf.Write(self.fmt.indent)!
					}
					if self.fmt.ubuf()[self.fmt.buf.Len()-1] == '\n' {
						self.fmt.buf.Write(self.fmt.indent)!
					}
					self.fmt.row = c.row + self.fmt.writeComment(c)
					self.write("\n")
				} else {
					break
				}
			}
			leadingComments = leadingComments[j:]
			// Respect space between cases.
			if erow.row-self.fmt.row > 1 {
				self.write("\n")
				self.fmt.buf.Write(self.fmt.indent)!
			}
			if self.fmt.ubuf()[self.fmt.buf.Len()-1] == '\n' {
				self.fmt.buf.Write(self.fmt.indent)!
			}

			self.fmt.buf.Write(expr)!

			// Write inline trailing comments.
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(exprs)-i < 2 || rows[i].row != rows[i+1].row {
				if n == 0 {
					max, n = self.getMax(exprs[i:], rows[i:], trailingComments[i:])
				}
				if n > 0 {
					for _, c in trailingComments[i] {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(expr))+1))
						self.fmt.writeComment(c)
					}
					n--
				}
			}

			if len(exprs)-i > 1 {
				self.write("\n")
			}
			self.fmt.row = erow.end
		}
		if self.fmt.ubuf()[self.fmt.buf.Len()-1] != '\n' && lined {
			self.write("\n")
		}
		if lined {
			self.fmt.addGlobalPaddingForCommentL(lit.Token.Row, lit.End.Row)
			const Pad = true
			self.fmt.writeCommentsExceptL(lit.Token.Row, lit.End.Row, Pad)
		}
		self.fmt.doneIndent()
		if lined {
			self.fmt.buf.Write(self.fmt.indent)!
		}
	}

	fn braceLit(&self, mut lit: &ast::BraceLit) {
		self.write("{")
		self.responsiveExprs[&ast::BraceLit](lit)
		self.write("}")
	}

	fn keyValPair(&self, mut pair: &ast::KeyValueExpr) {
		self.format(pair.Key)
		self.write(": ")
		self.format(pair.Value)
	}

	fn slice(&self, mut s: &ast::SliceExpr) {
		self.write("[")
		self.responsiveExprs[&ast::SliceExpr](s)
		self.write("]")
	}

	fn index(&self, mut i: &ast::IndexExpr) {
		self.format(i.X)
		self.write("[")

		zip := self.bf.zip
		self.bf.zip = true
		self.format(i.Index)
		self.bf.zip = zip

		self.write("]")
	}

	fn slicing(&self, mut i: &ast::SlicingExpr) {
		zip := self.bf.zip
		defer { self.bf.zip = zip }

		mut lb, mut rb, mut cb := false, false, false
		lr, rr, cr := isRanged(i.Low), isRanged(i.High), isRanged(i.Max)
		if !lr && i.Low != nil {
			_, isBinary := i.Low.Data.(&ast::BinaryExpr)
			if isBinary {
				lb = true
			}
		}
		if !rr && i.High != nil {
			_, isBinary := i.High.Data.(&ast::BinaryExpr)
			if isBinary {
				rb = true
			}
		}
		if !cr && i.Max != nil {
			_, isBinary := i.Max.Data.(&ast::BinaryExpr)
			if isBinary {
				cb = true
			}
		}

		self.format(i.X)
		self.write("[")

		self.bf.zip = zip || !lr
		self.format(i.Low)

		padding := !zip && (lb || rb || cb)
		if padding && i.Low != nil && i.High != nil {
			self.write(" : ")
		} else if padding && i.Low == nil && i.Max != nil {
			self.write(": ")
		} else {
			self.write(":")
		}

		self.bf.zip = zip || !rr
		self.format(i.High)

		if i.Max != nil {
			if padding {
				self.write(" : ")
			} else {
				self.write(":")
			}
			self.bf.zip = zip || !cr
			self.format(i.Max)
		}

		self.write("]")
	}

	fn chanSend(&self, mut c: &ast::ChanSend) {
		self.fmt.formatExpr(c.Chan)
		self.write(" <- ")
		self.fmt.formatExpr(c.X)
	}

	fn typeAssertion(&self, mut a: &ast::TypeAssertionExpr) {
		self.fmt.formatExpr(a.X)
		self.write(".(")
		self.fmt.formatType(a.Type)
		self.write(")")
	}

	fn formatKind(&self, mut kind: ast::ExprData) {
		match type kind {
		| &ast::RangeExpr:
			mut expr := kind.(&ast::RangeExpr)
			self.write("(")
			self.formatKind(expr.X.Data)
			self.write(")")
		| &ast::Func:
			self.fmt.fnDecl(kind.(&ast::Func))
		| &ast::NameExpr:
			self.name(kind.(&ast::NameExpr))
		| &ast::TupleExpr:
			self.tuple(kind.(&ast::TupleExpr))
		| &ast::LitExpr:
			self.lit(kind.(&ast::LitExpr))
		| &ast::UnsafeExpr:
			self.unsafexpr(kind.(&ast::UnsafeExpr))
		| &ast::UnaryExpr:
			self.unary(kind.(&ast::UnaryExpr))
		| &ast::VariadicExpr:
			self.variadic(kind.(&ast::VariadicExpr))
		| &ast::NamespaceExpr:
			self.namespace(kind.(&ast::NamespaceExpr))
		| &ast::SelectorExpr:
			self.selector(kind.(&ast::SelectorExpr))
		| &ast::BinaryExpr:
			self.binary(kind.(&ast::BinaryExpr))
		| &ast::CallExpr:
			self.call(kind.(&ast::CallExpr))
		| &ast::TypedBraceLit:
			self.typedBraceLit(kind.(&ast::TypedBraceLit))
		| &ast::BraceLit:
			self.braceLit(kind.(&ast::BraceLit))
		| &ast::KeyValueExpr:
			self.keyValPair(kind.(&ast::KeyValueExpr))
		| &ast::SliceExpr:
			self.slice(kind.(&ast::SliceExpr))
		| &ast::IndexExpr:
			self.index(kind.(&ast::IndexExpr))
		| &ast::SlicingExpr:
			self.slicing(kind.(&ast::SlicingExpr))
		| &ast::ChanSend:
			self.chanSend(kind.(&ast::ChanSend))
		| &ast::TypeAssertionExpr:
			self.typeAssertion(kind.(&ast::TypeAssertionExpr))
		| &ast::SliceType:
			self.sliceType(kind.(&ast::SliceType))
		| &ast::ArrayType:
			self.arrayType(kind.(&ast::ArrayType))
		| &ast::MapType:
			self.mapType(kind.(&ast::MapType))
		| &ast::ChanType:
			self.chanType(kind.(&ast::ChanType))
		}
	}

	fn format(&self, mut expr: &ast::Expr) {
		if expr == nil {
			ret
		}
		self.fmt.row = expr.Token.Row
		self.formatKind(expr.Data)
		self.fmt.row = expr.End.Row
	}
}

struct binaryFormatter {
	mut ef:   &exprFormatter
	mut zip:  bool
	mut op:   bool // result of [binaryFormatter.isOp]
	mut prec: bool // spacing by operator format precedence
	mut bin:  &ast::BinaryExpr
}

impl binaryFormatter {
	// Reports whether operator should take space for formatting.
	fn isOp(op: int): bool {
		ret op == token::LOR ||
			op == token::LAND ||
			op == token::GTR ||
			op == token::LSS ||
			op == token::LEQ ||
			op == token::GEQ ||
			op == token::EQL ||
			op == token::NEQ
	}

	// Reports whether the operator is have high formatting precedence.
	// Returns 1 for high precedence, otherwise returns 0.
	fn opPrec(op: int): int {
		match op {
		| token::SHL
		| token::SHR
		| token::MUL
		| token::QUO
		| token::REM
		| token::AND:
			ret 1
		|:
			ret 0
		}
	}

	// Reports whether operator zips operands.
	fn isHardZipOp(op: int): bool {
		ret op == token::LOR ||
			op == token::LAND
	}

	fn write(&self, s: str) {
		self.ef.write(s)
	}

	fn clean(&self) {
		self.zip = false
		self.op = false
		self.prec = false
		self.bin = nil
	}

	// writes space for operator if possible
	fn writeSpace(&self) {
		if self.op {
			self.write(" ")
			ret
		}
		// operator is not op

		if self.zip {
			// zip mode on following detection is disallowed
			ret
		}
		// zip mode is off

		if !self.prec {
			// prec mode is off
			self.write(" ")
			ret
		}
		// prec mode is on

		// write space if operator is not precedenced
		if binaryFormatter.opPrec(self.bin.Op.ID) == 0 {
			self.write(" ")
		}
	}

	fn head(&self, mut bin: &ast::BinaryExpr) {
		self.ef.fmt.popRowCommentsByC(bin.X.Token.Row, bin.X.Token.Column)
		self.format(bin.X)
		self.op = binaryFormatter.isOp(bin.Op.ID)
		self.writeSpace()
		self.ef.fmt.popRowCommentsByC(bin.Op.Row, bin.Op.Column)
		self.write(bin.Op.Kind)
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bin = bin
		self.head(self.bin)
		if self.bin.Op.Row == self.bin.Y.Token.Row {
			self.writeSpace()
			self.ef.fmt.popRowCommentsByC(self.bin.Y.Token.Row, self.bin.Y.Token.Column)
			self.format(self.bin.Y)
			ret
		}
		self.ef.fmt.addIndent()
		self.ef.fmt.popRowCommentsBy(self.bin.Op.Row)
		self.write("\n")
		self.ef.fmt.buf.Write(self.ef.fmt.indent)!
		self.ef.fmt.popRowCommentsByC(self.bin.Y.Token.Row, self.bin.Y.Token.Column)
		match type self.bin.Y.Data {
		| &ast::BinaryExpr:
			bin = self.bin.Y.Data.(&ast::BinaryExpr)
			if self.bin.Op.Row != self.bin.Y.Token.Row {
				self.binary(bin)
				self.ef.fmt.doneIndent()
			} else {
				self.ef.fmt.doneIndent()
				self.binary(bin)
			}
		|:
			self.format(self.bin.Y)
			self.ef.fmt.row = self.bin.Y.Token.Row
			self.ef.fmt.doneIndent()
		}
	}

	fn isZip(&self, mut kind: ast::ExprData): bool {
		match type kind {
		| &ast::BinaryExpr:
			mut bin := kind.(&ast::BinaryExpr)
			if binaryFormatter.isHardZipOp(bin.Op.ID) {
				ret true
			}
			ret self.isZip(bin.X.Data) || self.isZip(bin.Y.Data)
		|:
			ret false
		}
	}

	fn isPrec(&self, first: int, kind: ast::ExprData): int {
		match type kind {
		| &ast::BinaryExpr:
			bin := kind.(&ast::BinaryExpr)
			if first != binaryFormatter.opPrec(bin.Op.ID) {
				ret -1
			}
			mut prec := self.isPrec(first, bin.X.Data)
			if first != prec {
				ret -1
			}
			prec = self.isPrec(first, bin.Y.Data)
			if first != prec {
				ret -1
			}
			ret first
		|:
			ret first
		}
	}

	fn new(&self, mut bin: &ast::BinaryExpr) {
		if self.zip {
			ret
		}
		// detect zip
		if binaryFormatter.isOp(bin.Op.ID) {
			self.zip = true
			ret
		}
		self.zip = self.isZip(bin.X.Data) || self.isZip(bin.Y.Data)
		if self.zip {
			// skip if zipped, no need to detect following
			ret
		}

		// detect prec
		if !self.prec {
			// enable prec formatting if all operators is not have same prec
			first := binaryFormatter.opPrec(bin.Op.ID)
			self.prec = first != self.isPrec(first, bin.X.Data) || first != self.isPrec(first, bin.Y.Data)
		}
	}

	// Formats expression.
	// It designed for binary expressions operands only.
	fn format(&self, mut expr: &ast::Expr) {
		if expr == nil {
			ret
		}

		// store state of internal data
		zip := self.zip
		prec := self.prec
		mut bin := self.bin

		// format expression
		match type expr.Data {
		| &ast::BinaryExpr:
			// keep prec mode for tail
			break
		| &ast::CallExpr:
			self.zip = true

			// disable prec mode for non-tail expressions
			self.prec = false
		|:
			// enable zip mode if prec mode is enabled and
			// current binary operator have high precedence
			self.zip = self.zip || self.prec && binaryFormatter.opPrec(self.bin.Op.ID) == 1

			// disable prec mode for non-tail expressions
			self.prec = false
		}
		self.ef.format(expr)

		// save internal data
		self.zip = zip
		self.bin = bin
		self.prec = prec
	}
}

fn paddingAbs(x: int): int {
	if x < 0 {
		ret 0
	}
	ret x
}

fn isPrimType(t: &ast::Expr): bool {
	name, ok := t.Data.(&ast::NameExpr)
	ret ok && (name.Name == types::I8 ||
		name.Name == types::I16 ||
		name.Name == types::I32 ||
		name.Name == types::I64 ||
		name.Name == types::U8 ||
		name.Name == types::U16 ||
		name.Name == types::U32 ||
		name.Name == types::U64 ||
		name.Name == types::Int ||
		name.Name == types::Uint ||
		name.Name == types::Uintptr ||
		name.Name == types::F32 ||
		name.Name == types::F64 ||
		name.Name == types::Bool ||
		name.Name == types::Str ||
		name.Name == types::Any)
}

fn isRanged(e: &ast::Expr): bool {
	if e == nil {
		ret false
	}
	_, ok := e.Data.(&ast::RangeExpr)
	ret ok
}

fn isEmptyImpl(imp: &ast::Impl): bool {
	ret len(imp.Methods) == 0
}

fn cloneBuf(b: []byte): []byte {
	mut rb := make([]byte, len(b))
	copy(rb, b)
	ret rb
}

fn isGroupStmt(stmt: ast::Stmt): bool {
	match type stmt.Data {
	| &ast::TypeAlias
	| &ast::Var
	| &ast::Assign
	| &ast::Expr:
		ret true
	|:
		ret false
	}
}

fn indexRowBrake(rows: []int): int {
	for i, r in rows {
		if i > 0 && r-rows[i-1] > 1 {
			ret i
		}
	}
	ret len(rows)
}

fn isParentNeededForCall(expr: &ast::Expr): bool {
	f, _ := expr.Data.(&ast::Func)
	ret f != nil && f.IsDecl()
}