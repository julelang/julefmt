// Copyright 2024-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/bytes"
use "std/jule"
use "std/jule/ast"
use "std/jule/token"
use "std/jule/types"
use "std/slices"
use "std/strings"
use "std/unicode/utf8"

struct field {
	f:     &ast::Field
	token: &token::Token
	tag:   []byte
}

struct rowAlign {
	row: int
	end: int
	col: int
	max: bool
}

struct formatter {
	indentLen: int
	indentStr: str

	mut i:      int
	mut buf:    strings::Builder
	mut f:      &ast::AST
	mut indent: []byte
	mut cm:     commentMap
	mut row:    int

	mut ef: &exprFormatter
	mut sf: &scopeFormatter
	mut tf: &typeFormatter
}

impl formatter {
	static fn new(): &formatter {
		mut fmt := new(formatter)
		fmt.ef = exprFormatter.new(fmt)
		fmt.sf = &scopeFormatter{fmt: fmt}
		fmt.tf = &typeFormatter{fmt: fmt}
		fmt.indentLen = 1
		fmt.indentStr = "\t"
		ret fmt
	}

	fn ubuf(self): []byte {
		ret unsafe { self.buf.Buf() }
	}

	fn setBuf(self, mut b: []byte) {
		unsafe { self.buf.SetBuf(b) }
	}

	fn write(&self, s: str) {
		self.buf.WriteStr(s)!
	}

	fn addIndent(&self) {
		static indent = []byte(strings::Repeat(self.indentStr, self.indentLen))
		self.indent = append(self.indent, indent...)
	}

	fn doneIndent(&self) {
		self.indent = self.indent[:len(self.indent)-self.indentLen]
	}

	fn writeComment(&self, &c: &comment) {
		if len(self.indent) > 0 && c.txt[1] == '*' {
			// Range comment should be checked.
			// Ending is should be padded by indentation.
			mut i := utf8::RuneCountStr(c.txt) - 3
		lookup:
			for i > 1; i-- {
				b := c.txt[i]
				match b {
				| ' ' | '\t' | '\v' | '\r':
					continue
				| '\n':
					cmt := c.txt[:i+1]
					i = bytes::LastIndexByte(self.ubuf(), '\n')
					self.write(cmt)
					self.buf.Write(self.indent)!
					self.write("*/")
					ret
				|:
					break lookup
				}
			}
		}
		if c.txt[1] == '/' {
			// Single-line comment, trim trailing spaces before writing.
			self.write(strings::TrimRight(c.txt, " \t\v\b"))
			ret
		}
		self.write(c.txt)
	}

	fn seekCommentExcept(&self, row: int): &comment {
		for (_, mut c) in self.cm.buf {
			if row != -1 && c.row >= row {
				break
			}
			ret c
		}
		ret nil
	}

	fn writeCommentsExceptL(&self, start: int, row: int, pad: bool): int {
		mut lrow := row
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if start != -1 && c.row < start {
				i++
				continue
			} else if row != -1 && c.row >= row {
				break
			}
			if pad && c.row-lrow > 1 {
				self.write("\n")
			}
			lrow = c.row
			self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
			self.buf.Write(self.indent)!
			self.writeComment(c)
			if c.txt[1] == '*' {
				// If comment is range, it might include new-lines.
				// Count them and add to lrow for correct row calculation.
				lrow += strings::Count(c.txt, "\n")
			}
			self.write("\n")
		}
		ret lrow
	}

	fn writeCommentsExcept(&self, row: int): int {
		const Pad = true
		ret self.writeCommentsExceptL(-1, row, Pad)
	}

	fn writeComments(&self, row: int): int {
		ret self.writeCommentsExcept(row + 1)
	}

	fn addGlobalPaddingForCommentL(&self, start: int, row: int) {
		mut i := 0
		for i < len(self.cm.buf); i++ {
			c := self.cm.buf[i]
			if c.row >= start && c.row <= row {
				if c.row-self.row > 1 {
					self.write("\n")
				}
				break
			}
		}
	}

	fn addGlobalPaddingForComment(&self, row: int): bool {
		c := self.cm.first(row)
		if c != nil && c.row-self.row > 1 {
			self.write("\n")
			ret true
		}
		ret false
	}

	fn writeRemainingComments(&self) {
		self.addGlobalPaddingForComment(-1)
		self.writeCommentsExcept(-1)
	}

	fn isPopsRowCommentsByF(self, row: int, col: int): bool {
		mut i := 0
		for i < len(self.cm.buf); i++ {
			c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				ret true
			} else if c.row > row {
				ret false
			}
		}
		ret false
	}

	fn popRowCommentsUntilByF(&self, row: int, col: int, f: fn(&comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if c.row > row {
				break
			}
			if col == -1 || c.col < col {
				f(c)
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			}
			i++
		}
	}

	fn popRowCommentsByF(&self, row: int, col: int, f: fn(&comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				f(c)
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			} else if c.row > row {
				break
			}
			i++
		}
	}

	fn popRowCommentsBy(&self, row: int) {
		self.popRowCommentsByF(row, -1, fn(c: &comment) {
			self.write(" ")
			self.writeComment(c)
		})
	}

	fn popRowCommentsByC(&self, row: int, col: int) {
		self.popRowCommentsByF(row, col, fn(c: &comment) {
			self.write(c.txt)
			self.write(" ")
		})
	}

	fn popRowComments(&self, row: int) {
		for {
			c := self.cm.pop(row)
			if c == nil {
				break
			}
			self.write(" ")
			self.writeComment(c)
		}
	}

	fn formatExpr(&self, mut &expr: &ast::Expr) {
		self.ef.format(expr)
		self.ef.clean()
	}

	fn formatType(&self, mut &expr: &ast::Type) {
		self.tf.format(expr.Kind)
	}

	fn formatScope(&self, mut &scope: &ast::ScopeTree, options: scopeOption) {
		self.sf.format(scope, options)
	}

	fn directive(&self, &d: &ast::Directive) {
		self.write("#")
		self.write(d.Tag.Kind)
		for i, arg in d.Args {
			match {
			| i == 0:
				self.write(" ")
			| arg.Id != token::RParent &&
				d.Args[i-1].Id != token::LParent &&
				d.Args[i-1].Id != token::Excl:
				self.write(" ")
			}
			self.write(arg.Kind)
		}
	}

	fn directives(&self, dvs: []&ast::Directive) {
		if len(dvs) == 0 {
			ret
		}
		first := dvs[0]
		if first.Tag.Row-self.writeCommentsExcept(first.Tag.Row) > 1 {
			self.write("\n")
		}
		for i, d in dvs {
			if i > 0 {
				self.buf.Write(self.indent)!
			}
			self.writeCommentsExcept(d.Tag.Row)
			self.directive(d)
			self.popRowComments(d.Tag.Row)
			self.write("\n")
			self.row = d.Tag.Row
		}
	}

	fn useDecl(&self, d: &ast::Use) {
		if d.Binded {
			self.write("cpp ")
		}
		self.write("use ")
		if d.Alias != nil {
			self.write(d.Alias.Kind)
			self.write(" ")
		}
		self.write(d.Path.Kind)
	}

	fn useDecls(&self) {
		if len(self.f.UseDecls) == 0 {
			ret
		}
		if len(self.f.TopDirectives) > 0 {
			self.write("\n\n")
		}

		// Write all-comments first.
		// Do this before ordering use declarations to find correct last comment.
		{
			first := self.f.UseDecls[0]
			self.addGlobalPaddingForComment(first.Token.Row)
			self.row = self.writeComments(first.Token.Row)
			if first.Token.Row-self.row > 1 {
				self.write("\n")
			}
			const Pad = false
			self.writeCommentsExceptL(-1, self.f.UseDecls[len(self.f.UseDecls)-1].Token.Row+1, Pad)
		}

		// Sort imports.
		// See formatter documentation how ordering will be made.
		slices::SortFunc(self.f.UseDecls, fn(a: &ast::Use, b: &ast::Use): int {
			if a.Binded != b.Binded {
				if a.Binded {
					ret +1
				}
				ret -1
			}
			// a.Binded == b.Binded
			if a.Binded {
				ret strings::Compare(a.Path.Kind, b.Path.Kind)
			}
			const StdPrefix = `"std/`
			aStd := strings::HasPrefix(a.Path.Kind, StdPrefix)
			bStd := strings::HasPrefix(b.Path.Kind, StdPrefix)
			if aStd == bStd {
				ret strings::Compare(a.Path.Kind, b.Path.Kind)
			}
			if aStd && !bStd {
				ret +1
			}
			ret -1
		})

		mut binded := false // whether any binded import seen
		for i, decl in self.f.UseDecls {
			if !binded && decl.Binded {
				binded = true
				if i > 0 {
					// ordinary import seen
					// separate binded imports
					self.write("\n")
				}
			}
			self.row = decl.Token.Row
			self.useDecl(decl)
			if len(self.f.UseDecls)-i > 1 {
				self.write("\n")
			}
		}
	}

	fn generics(&self, mut &g: []&ast::Generic) {
		if len(g) == 0 {
			ret
		}
		self.write("[")
		for (i, mut t) in g {
			self.write(t.Ident)
			if t.Constraint != nil {
				self.write(": ")
				for (j, mut c) in t.Constraint.Mask {
					self.formatType(c)
					if len(t.Constraint.Mask)-j > 1 {
						self.write(" | ")
					}
				}
			}
			if i+1 < len(g) {
				self.write(", ")
			}
		}
		self.write("]")
	}

	fn enumItem[T](&self, mut &item: T) {
		const match type T {
		| &ast::EnumItem:
			self.write(item.Ident)
			if !item.AutoExpr() {
				self.write(": ")
				self.formatExpr(item.Expr)
			}
		| &ast::TypeEnumItem:
			self.formatType(item.Kind)
		}
		self.write(",")
	}

	fn enumDecl[T](&self, mut d: T) {
		self.write("enum ")
		self.write(d.Ident)
		const match type T {
		| &ast::Enum:
			if !d.DefaultTyped() {
				self.write(": ")
				self.formatType(d.Kind)
			}
		| &ast::TypeEnum:
			self.write(": type")
		}
		self.write(" {")
		if len(d.Items) > 0 {
			self.write("\n")
			self.addIndent()
			mut i, mut row := 0, 0
			for i < len(d.Items) {
				old := self.i
				item := d.Items[i]
				const match type T {
				| &ast::Enum:
					self.groupDecls[&ast::EnumItem, &ast::EnumItem](d.Items, i, fn(mut &d: &ast::EnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::EnumItem](d)
					})
				| &ast::TypeEnum:
					self.groupDecls[&ast::TypeEnumItem, &ast::TypeEnumItem](d.Items, i, fn(mut &d: &ast::TypeEnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::TypeEnumItem](d)
					})
				}
				if i < len(d.Items) {
					if !self.addGlobalPaddingForComment(d.End.Row) && old != i {
						self.write("\n")
					}
				}
				row = item.Token.Row
			}
			self.addGlobalPaddingForComment(d.End.Row)
			self.writeCommentsExcept(d.End.Row)
			self.doneIndent()
		}
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn params(&self, mut &f: &ast::Func) {
		if len(f.Params) == 0 {
			self.write("()")
			ret
		}
		self.write("(")
		mut indented := false
		self.row = f.Token.Row
		for (i, mut p) in f.Params {
			if self.row != p.Token.Row {
				self.write("\n")
				if !indented {
					indented = true
					self.addIndent()
				}
				self.buf.Write(self.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.popRowCommentsByC(p.Token.Row, p.Token.Column)
			if p.Mutable {
				self.write("mut ")
			}
			if p.Reference {
				self.write("&")
			}
			if p.IsSelf() {
				if p.IsRef() {
					self.write("&")
				}
				self.write("self")
			} else {
				if !jule::IsAnon(p.Ident) {
					self.write(p.Ident)
					self.write(": ")
				} else if p.Reference {
					self.write("_: ")
				}
				self.popRowCommentsByC(p.Kind.Token.Row, p.Kind.Token.Column)
				if p.Variadic {
					self.write("...")
				}
				self.formatType(p.Kind)
			}
			if i+1 < len(f.Params) {
				self.write(",")
				if f.Params[i+1].Token.Row != p.Token.Row {
					self.popRowCommentsByF(p.Token.Row, -1, fn(c: &comment) {
						self.write(" ")
						self.writeComment(c)
					})
				}
			}
			self.row = p.Token.Row
		}
		if indented {
			self.doneIndent()
		}
		self.write(")")
	}

	fn fnDecl(&self, mut d: &ast::Func) {
		if !d.IsAnon() {
			self.writeCommentsExcept(d.Token.Row)
			self.buf.Write(self.indent)!
		}
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
			self.buf.Write(self.indent)!
		}
		if d.Statically {
			self.write("static ")
		}
		if d.Binded {
			self.write("cpp ")
		}
		if d.Unsafety {
			self.write("unsafe ")
		}
		self.write("fn")
		if !jule::IsAnon(d.Ident) {
			self.write(" ")
			self.write(d.Ident)
		}
		self.generics(d.Generics)
		self.params(d)
		if d.Exceptional {
			self.write("!")
		}
		if d.Result.Kind != nil {
			self.write(": ")
			self.tf.result(d.Result)
		}
		if d.Scope != nil {
			self.write(" ")
			unsafety := d.Unsafety
			d.Scope.Unsafety = false // Avoid unsafe keyword beginning of scope.
			self.formatScope(d.Scope, scopeDefault|scopePopByC)
			d.Scope.Unsafety = unsafety
			self.row = d.Scope.End.Row
		}
	}

	// Only parses last field.
	// Leading fields used to calculate maximum declaration length of group for padding.
	fn field(&self, mut f: &field, mut fieldMax: int, mut typeMax: int) {
		self.buf.Write(self.indent)!
		if f.f.Mutable {
			self.write("mut ")
			fieldMax -= 4
		}
		self.write(f.f.Ident)
		fieldMax -= utf8::RuneCountStr(f.f.Ident)
		self.write(": ")
		if fieldMax > 0 {
			self.write(strings::Repeat(" ", fieldMax))
		}
		n := len(self.ubuf())
		self.formatType(f.f.Kind)
		typeMax -= utf8::RuneCount(self.ubuf()[n:])
		if len(f.tag) != 0 {
			if typeMax > 0 {
				self.write(strings::Repeat(" ", typeMax))
			}
			self.write(" ")
			self.buf.Write(f.tag)!
		}
	}

	fn fields(&self, mut &fields: []&ast::Field) {
		if len(fields) == 0 {
			ret
		}
		mut flds := make([]&field, 0, len(fields))
		for (_, mut f) in fields {
			flds = append(flds, &field{
				f: f,
				token: f.Token,
			})
		}
		mut i := 0
		for i < len(flds) {
			old := i
			self.fieldGroupDecls(flds, i)
			if old != i {
				if i < len(flds) {
					self.write("\n")
				}
			} else {
				i++
			}
		}
	}

	fn structDecl(&self, mut d: &ast::Struct) {
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
		} else {
			if d.Token.Row-self.writeComments(d.Token.Row) > 1 {
				self.write("\n")
			}
		}
		if d.Binded {
			self.write("cpp ")
		}
		self.write("struct ")
		self.write(d.Ident)
		self.generics(d.Generics)
		if len(d.Fields) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row)
			ret
		}
		self.write(" {\n")
		self.addIndent()
		self.fields(d.Fields)
		self.addGlobalPaddingForComment(d.End.Row)
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn traitDecl(&self, mut d: &ast::Trait) {
		self.write("trait ")
		self.write(d.Ident)
		if len(d.Methods) == 0 && len(d.Inherits) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row)
			ret
		}
		self.write(" {")
		self.addIndent()
		self.row = d.Token.Row
		for (i, mut ih) in d.Inherits {
			self.write("\n")
			if i > 0 && ih.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(ih.Token.Row)
			self.buf.Write(self.indent)!
			self.formatType(ih)
			self.popRowComments(ih.Token.Row)
			self.row = ih.Token.Row
		}
		if len(d.Inherits) > 0 && len(d.Methods) > 0 {
			if d.Methods[0].Token.Row-self.row > 1 {
				self.write("\n")
			}
		}
		for (i, mut m) in d.Methods {
			self.write("\n")
			if i > 0 && m.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(m.Token.Row)
			self.fnDecl(m)
			self.popRowComments(m.Token.Row)
		}
		// Function declaration formatting won't add new-line.
		// So add a new-line to complete "\n\n" if needed.
		// addGlobalPaddingForComment adds one "\n" if needed.
		pad := self.addGlobalPaddingForComment(d.End.Row) || self.seekCommentExcept(d.End.Row) != nil
		if pad {
			self.write("\n")
		}
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		// If padding enabled, there is comment.
		// So comment writer will write a new-line after comment.
		// Avoid to write a new-line after comments.
		if !pad {
			self.write("\n")
		}
		self.write("}")
		self.popRowComments(d.End.Row)
		self.row = d.End.Row
	}

	fn typeAliasDecl(&self, mut d: &ast::TypeAlias) {
		if d.Binded {
			self.write("cpp ")
		}
		self.write("type ")
		self.write(d.Ident)
		if d.Strict {
			self.write(": ")
		} else {
			self.write(" = ")
		}
		self.formatType(d.Kind)
	}

	fn varDecl(&self, mut d: &ast::Var, head: bool, mut counts: [5]int) {
		// Layout of counts.
		mut typeAnnoMax := counts[0]      // maximum name length for type alignment column
		mut nameMax := counts[1]          // maximum name length of the group
		nameMaxHaveType := counts[2] == 1 // whether nameMax owner have type annotation
		mut typeMax := counts[3]          // maximum length of the type annotations
		table := counts[4] == 1           // whether the alignment is like table, column-by-column

		if head {
			if len(d.Directives) != 0 {
				self.directives(d.Directives)
			}
			if d.Binded {
				self.write("cpp let ")
			} else {
				if d.Statically {
					self.write("static ")
				} else if d.Constant {
					self.write("const ")
				} else if d.Setter == nil || d.Setter.Id == token::Eq {
					self.write("let ")
				}
			}
			if d.Mutable {
				self.write("mut ")
			}
			if d.Reference {
				self.write("&")
			}
		}
		nameLen := utf8::RuneCountStr(d.Ident)
		self.write(d.Ident)
		self.row = d.Token.Row
		mut typ := 0
		if d.Kind != nil {
			self.write(": ")
			// If typeAnnoMax>0, add the missing leading spaces for type annotation.
			if typeAnnoMax > 0 {
				diff := typeAnnoMax - nameLen
				if diff > 0 {
					self.write(strings::Repeat(" ", diff))
				}
			}
			n := len(self.ubuf())
			self.formatType(d.Kind)
			typ = utf8::RuneCount(self.ubuf()[n:]) // subtract the runes of type
			self.row = d.Kind.Token.Row
		}
		if d.Expr != nil {
			// If nameMax>0, we have to do alignment.
			if nameMax > 0 {
				// If typeMax>0 and d.Kind==nil, we have type alignment.
				// But this variable have not type annotation.
				// Add spaces for the missing ": " part of type annotations.
				if (nameMaxHaveType || table) && typeMax > 0 && d.Kind == nil {
					nameMax += 2
				}
				// If the maximum name have not type annotation and this variable have,
				// remove the spaces of the ": " part of type annotations.
				if !nameMaxHaveType && d.Kind != nil {
					nameMax -= 2
				}
				// If we have type alignment and this variable have type annotation,
				// add missing trailing spaces to reach maximum type annotation length.
				if typeMax > 0 && d.Kind != nil {
					diff := typeMax - typ
					if diff > 0 {
						self.write(strings::Repeat(" ", diff))
					}
					// Remove the added spaces from alignment.
					nameMax -= diff
				}
				// Remove the spaces of type annotation length of this variable.
				nameMax -= typ
				// If type annotation alignemnt exist and this variable have type annotation,
				// remove the spaces of annotation alignment, because type annotation is aligned.
				// Otherwise, remove spaces for name length,
				// there are still missing spaces for type annotations.
				if typeAnnoMax > 0 && d.Kind != nil {
					nameMax -= typeAnnoMax
				} else {
					nameMax -= nameLen
				}
				if nameMax > 0 {
					self.write(strings::Repeat(" ", nameMax))
				}
			}
			self.write(" ")
			self.write(d.Setter.Kind)
			self.write(" ")
			self.formatExpr(d.Expr)
			self.row = d.Expr.End.Row
		}
	}

	fn getMax(self, lines: [][]byte, rows: []int): (max: int, n: int) {
		if !self.isPopsRowCommentsByF(rows[0], -1) {
			ret
		}
		max = utf8::RuneCount(lines[0])
		n = 1
		for n < len(lines); n++ {
			if rows[n-1] == rows[n] || !self.isPopsRowCommentsByF(rows[n], -1) {
				break
			}
			diff := utf8::RuneCount(lines[n])
			if max < diff {
				max = diff
			}
		}
		ret
	}

	fn fieldGroupDecls(&self, mut fields: []&field, mut &i: int) {
		mut lines := make([][]byte, 0, len(fields))
		mut rows := make([]int, 0, len(fields))

		mut start := i
		self.row = -1
		mut fieldMax := 0
		mut typeMax := 0
		mut n := self.buf.Len()
		for i < len(fields) {
			mut decl := fields[i]
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && decl.token.Row-rows[(i-start)-1] > 1 {
				break
			}
			self.row = decl.token.Row
			mut fm := 0
			if decl.f.Mutable {
				fm += len("mut ")
			}
			fm += utf8::RuneCountStr(decl.f.Ident)
			self.formatType(decl.f.Kind)
			tm := utf8::RuneCount(self.ubuf()[n:])
			self.setBuf(self.ubuf()[:n])
			if row != -1 && decl.token.Row != self.row {
				break
			}
			if decl.f.Tag != nil {
				self.write(decl.f.Tag.Kind)
				decl.tag = cloneBuf(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
			}
			if row != -1 && decl.token.Row != self.row {
				break
			}
			rows = append(rows, decl.token.Row)
			if fm > fieldMax {
				fieldMax = fm
			}
			if tm > typeMax {
				typeMax = tm
			}
			i++
		}

		mut j := start
		for j < i; j++ {
			mut f := fields[j]
			self.field(f, fieldMax, typeMax)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			self.setBuf(self.ubuf()[:n])
		}

		n = 0
		mut max := 0
		for k, line in lines {
			row := rows[k]
			self.writeCommentsExcept(row)
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-k < 2 || rows[k] != rows[k+1] {
				if n == 0 {
					max, n = self.getMax(lines[k:], rows[k:])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			self.write("\n")
			start++
		}
	}

	fn varSubGroup(&self, mut vars: []&ast::Var, mut &i: int) {
		// Do not increase the i, because all grouped variables are represented by the root.
		mut lines := make([][]byte, 0, len(vars[i:]))
		mut rows := make([]int, 0, len(vars[i:]))
		mut counts := make([][2]int, 0, len(vars[i:]))

		start := i
		mut n := self.buf.Len()

		// Returns maximum length of identifiers for type annotation alignment.
		// j is the current varaible.
		getTypeAnnoMax := fn(mut j: int): (nameMax: int) {
			counts = counts[:unsafe { i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.Kind != nil {
					j--
				} else {
					break
				}
			}
			for j < unsafe { i }; j++ {
				mut v := vars[j]
				if v.Kind != nil {
					name := counts[j-start][0]
					if name > nameMax {
						nameMax = name
					}
				} else {
					break
				}
			}
			ret
		}

		// Returns maximum length of assignment alignment.
		// j is the current varaible
		getAssignMax := fn(mut j: int, mut &typeAnnoMax: int): (nameMax: int, nameMaxHaveType: int, typeMax: int, table: int) {
			counts = counts[:unsafe { i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.Expr != nil || self.isPopsRowCommentsByF(v.Token.Row, -1) {
					j--
				} else {
					break
				}
			}
			mut fullComment := true // whether the all group members have comment
			mut maxPlainName := 0
			mut maxNameWithType := typeAnnoMax
			for j < unsafe { i }; j++ {
				mut v := vars[j]
				comment := self.isPopsRowCommentsByF(v.Token.Row, -1)
				if v.Expr == nil && !comment {
					break
				}
				fullComment = fullComment && comment
				c := counts[j-start]
				t := c[0]
				if maxPlainName < t {
					maxPlainName = t
				}
				if v.Kind != nil {
					if maxNameWithType < t {
						maxNameWithType = t
					}
				}
				if c[1] > typeMax {
					typeMax = c[1]
				}
			}
			if fullComment {
				table = 1
				// typeAnnoMax must strore the maximum length of the group for type alignment.
				typeAnnoMax = maxNameWithType
				if typeAnnoMax < maxPlainName {
					typeAnnoMax = maxPlainName
				}
				// add typeMax to maxPlainName for type alignment.
				// Because all the group must be aligned column-by-column.
				maxPlainName += typeMax
			}
			maxNameWithType += typeMax
			maxNameWithType += 2 // add space for ": " part of type annotation
			if maxNameWithType > maxPlainName {
				maxNameWithType -= 2 // remove space for ": " part of type annotation
				nameMax = maxNameWithType
				nameMaxHaveType = 1
			} else {
				nameMax = maxPlainName
				nameMaxHaveType = 0
			}
			ret
		}

		self.row = -1
		for i < len(vars); i++ {
			mut v := vars[i]
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && v.Token.Row-vars[i-1].Token.Row > 1 {
				break
			}
			self.row = v.Token.Row
			mut name := utf8::RuneCountStr(v.Ident)
			mut typ := 0
			if v.Kind != nil {
				self.formatType(v.Kind)
				typ = utf8::RuneCount(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			if v.Expr != nil {
				self.formatExpr(v.Expr)
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			counts = append(counts, [name, typ])
		}
		mut z := start
		for z < i; z++ {
			mut typeAnnoMax := getTypeAnnoMax(z)
			nameMax, nameMaxHaveType, typeMax, table := getAssignMax(z, typeAnnoMax)
			self.varDecl(vars[z], false, [typeAnnoMax, nameMax, nameMaxHaveType, typeMax, table])
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
		}
		n = 0
		mut max := 0
		mut rowBreak := indexRowBrake(rows)
		for j, line in lines {
			row := rows[j]
			if j == rowBreak {
				self.write("\n")
				rowBreak = j + indexRowBrake(rows[j:])
			}
			self.writeCommentsExcept(row)
			self.buf.Write(self.indent)!
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:rowBreak], rows[j:rowBreak])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			self.write("\n")
		}
		self.row = rows[len(rows)-1] + 1 // Add +1 offset for "\n)" suffix.
	}

	fn varGroup(&self, mut root: &ast::Var, mut &i: int) {
		// Do not increase the i, because all grouped variables are represented by the root.
		self.buf.Write(self.indent)!
		self.write("const (\n")
		self.addIndent()
		mut j := 0
		for j < len(root.Group) {
			old := j
			self.varSubGroup(root.Group, j)
			if old != j {
				if j < len(root.Group) {
					self.write("\n")
				}
			} else {
				j++
			}
		}
		self.doneIndent()
		self.buf.Write(self.indent)!
		self.write(")")
	}

	fn groupDecls[T, Node](&self, mut nodes: []Node, mut &i: int, writer: fn(mut &d: T)) {
		if len(nodes) == 0 {
			ret
		}

		// If group declaration used, fall-back to special group handling.
		const match type T {
		| &ast::Var:
			const match type Node {
			| &ast::Var:
				if nodes[i].Group != nil {
					self.varGroup(nodes[i], i)
					ret
				}
			| ast::Node | ast::Stmt:
				mut v, ok := nodes[i].Data.(T)
				if ok && v.Group != nil {
					self.varGroup(v, i)
					ret
				}
			}
		| ast::Node | ast::Stmt:
			mut v, ok := nodes[i].Data.(&ast::Var)
			if ok && v.Group != nil {
				self.varGroup(v, i)
				ret
			}
		}

		const Cap = 1 << 4
		mut lines := make([][]byte, 0, Cap)
		mut rows := make([]int, 0, Cap)

		all := i == -1
		if all {
			i = 0
		}

		self.row = -1
		mut n := self.buf.Len()
	loop:
		for i < len(nodes) {
			let mut decl: T
			mut row := -1
			const match type Node {
			| &ast::Var:
				if nodes[i].Group != nil {
					break loop
				}
				fall
			| &ast::EnumItem
			| &ast::TypeEnumItem
			| &ast::Func:
				decl = nodes[i]
				row = decl.Token.Row
			| ast::Stmt:
				decl = nodes[i]
				if !isGroupStmt(decl) {
					break loop
				}
				v, ok := decl.Data.(&ast::Var)
				if ok && v.Group != nil {
					break loop
				}
				row = decl.End.Row
			| ast::Node:
				node := nodes[i]
				match type node.Data {
				| T:
					decl = nodes[i].Data.(T)
					row = decl.Token.Row
				|:
					break loop
				}
			|:
				panic("groupDecls: unimplemented type")
			}
			if !all && self.row != -1 && row-self.row > 1 {
				break loop
			}
			self.row = row
			writer(decl)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
			i++
			const match type Node {
			| ast::Stmt:
				if decl.Token.Row != decl.End.Row {
					// break if start row and end row is not same of stmt
					break loop
				}
			}
		}

		n = 0
		mut max := 0
		for j, line in lines {
			row := rows[j]
			self.writeCommentsExcept(row)
			self.buf.Write(line)!
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:], rows[j:])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			self.write("\n")
		}
	}

	fn writeImplNodes[T](&self, mut &nodes: []T, writer: fn(mut &d: T)) {
		self.write("\n")
		mut j := 0
		for j < len(nodes) {
			self.groupDecls[T, T](nodes, j, writer)
			if j < len(nodes) {
				self.write("\n")
			}
		}
	}

	fn implDecl(&self, mut d: &ast::Impl) {
		self.write("impl ")
		if d.IsTraitImpl() {
			self.formatType(d.Base)
			self.write(" for ")
		}
		self.formatType(d.Dest)
		if isEmptyImpl(d) {
			self.write(" {}")
			self.popRowComments(d.End.Row)
			ret
		}

		self.write(" {")
		self.addIndent()
		self.writeImplNodes[&ast::Func](d.Methods, fn(mut &d: &ast::Func) {
			self.fnDecl(d)
		})
		self.addGlobalPaddingForComment(d.End.Row)
		self.writeCommentsExcept(d.End.Row)
		self.doneIndent()
		self.write("}")
		self.popRowComments(d.End.Row)
	}

	fn groupNode[T](&self, &node: ast::Node, writer: fn(mut &d: T)) {
		mut row := node.Token.Row
		const match type T {
		| &ast::TypeAlias:
			break
		|:
			data := node.Data.(T)
			if len(data.Directives) > 0 {
				row = data.Directives[0].Tag.Row
			}
		}
		if row-self.writeCommentsExcept(row) > 1 {
			self.write("\n")
		}
		self.groupDecls[T, ast::Node](self.f.Nodes, self.i, writer)
	}

	fn node(&self, mut &node: ast::Node) {
		match type node.Data {
		| &ast::TypeAlias:
			self.groupNode[&ast::TypeAlias](node, fn(mut &d: &ast::TypeAlias) {
				self.buf.Write(self.indent)!
				self.typeAliasDecl(d)
			})
			ret
		| &ast::Var:
			self.groupNode[&ast::Var](node, fn(mut &d: &ast::Var) {
				self.buf.Write(self.indent)!
				self.varDecl(d, true, [])
			})
			ret
		| &ast::Func:
			self.groupNode[&ast::Func](node, fn(mut &d: &ast::Func) {
				self.fnDecl(d)
			})
			ret
		| &ast::Struct:
			self.structDecl(node.Data.(&ast::Struct))
		|:
			// no-op
		}
		mut commentExist := self.cm.find(node.Token.Row) != nil
		if node.Token.Row-self.writeComments(node.Token.Row) > 1 {
			self.write("\n")
		}
		match type node.Data {
		| &ast::Enum:
			self.enumDecl[&ast::Enum](node.Data.(&ast::Enum))
		| &ast::TypeEnum:
			self.enumDecl[&ast::TypeEnum](node.Data.(&ast::TypeEnum))
		| &ast::Trait:
			self.traitDecl(node.Data.(&ast::Trait))
		| &ast::Impl:
			mut imp := node.Data.(&ast::Impl)
			isGroupHeader := !commentExist && isEmptyImpl(imp)
			self.implDecl(imp)
			mut i := self.i
			if !isGroupHeader {
				ret
			}
			self.i++
		lookup:
			for self.i < len(self.f.Nodes); self.i++ {
				node = self.f.Nodes[self.i]
				match type node.Data {
				| &ast::Impl:
					imp = node.Data.(&ast::Impl)
					if !isEmptyImpl(imp) || self.cm.find(node.Token.Row) != nil {
						break lookup
					}
					self.write("\n")
					self.implDecl(imp)
				|:
					break lookup
				}
			}
			if self.i != i {
				// Add newline to be removed by the [nodes] method.
				self.write("\n")
			}
		|:
			// no-op
		}
	}

	fn nodes(&self) {
		self.i = 0
		self.row = 0
		for self.i < len(self.f.Nodes); self.i++ {
			mut node := self.f.Nodes[self.i]
			old := self.i
			self.write("\n\n")
			self.node(node)
			if old != self.i {
				self.i--
				self.setBuf(self.ubuf()[:self.buf.Len()-1]) // Remove trailing newline.
			}
		}
		self.writeRemainingComments()
	}

	fn format(&self, mut &f: &ast::AST, mut &cm: commentMap): []byte {
		self.cm = cm
		self.f = f
		self.directives(self.f.TopDirectives)
		if len(self.f.TopDirectives) > 0 {
			self.setBuf(self.ubuf()[:self.buf.Len()-1]) // Remove trailing newline.
		}
		self.useDecls()
		self.nodes()
		self.f = nil
		ret bytes::Trim(self.ubuf(), " \f\n\r\v\t")
	}
}

struct typeFormatter {
	mut fmt: &formatter
}

impl typeFormatter {
	fn write(self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn generics(self, mut g: []&ast::Type) {
		if len(g) == 0 {
			ret
		}
		self.write("[")
		for (i, mut t) in g {
			self.format(t.Kind)
			if i+1 < len(g) {
				self.write(", ")
			}
		}
		self.write("]")
	}

	fn ident(self, mut id: &ast::IdentType) {
		if id.Binded {
			self.write("cpp.")
		}
		self.write(id.Ident)
		self.generics(id.Generics)
	}

	fn namespace(self, mut ns: &ast::NamespaceType) {
		self.write(ns.Namespace.Kind)
		self.write("::")
		self.format(ns.Kind.Kind)
	}

	fn sptr(self, mut sptr: &ast::SptrType) {
		self.write("&")
		self.format(sptr.Elem.Kind)
	}

	fn slice(self, mut slc: &ast::SliceType) {
		self.write("[]")
		self.format(slc.Elem.Kind)
	}

	fn ptr(self, mut ptr: &ast::PtrType) {
		self.write("*")
		if ptr.IsUnsafe() {
			self.write("unsafe")
			ret
		}
		self.format(ptr.Elem.Kind)
	}

	fn array(self, mut arr: &ast::ArrayType) {
		self.write("[")
		if arr.AutoSized() {
			self.write("...")
		} else {
			self.fmt.formatExpr(arr.Size)
		}
		self.write("]")
		self.format(arr.Elem.Kind)
	}

	fn mapType(self, mut m: &ast::MapType) {
		self.write("map[")
		self.format(m.Key.Kind)
		self.write("]")
		self.format(m.Val.Kind)
	}

	fn result(self, mut r: &ast::RetType) {
		if len(r.Idents) == 0 {
			self.format(r.Kind.Kind)
			ret
		}
		if len(r.Idents) == 1 {
			if jule::IsAnon(r.Idents[0].Kind) {
				self.format(r.Kind.Kind)
				ret
			}
			self.write("(")
			self.write(r.Idents[0].Kind)
			self.write(": ")
			self.format(r.Kind.Kind)
			self.write(")")
			ret
		}
		mut types := r.Kind.Kind.(&ast::TupleType).Types
		self.write("(")
		for (i, mut t) in types {
			ident := r.Idents[i]
			if jule::IsAnon(ident.Kind) {
				self.format(t.Kind)
			} else {
				self.write(ident.Kind)
				self.write(": ")
				self.format(t.Kind)
			}
			if len(types)-i > 1 {
				self.write(", ")
			}
		}
		self.write(")")
	}

	fn chanType(self, mut c: &ast::ChanType) {
		mut range := false
		if c.Recv && c.Send {
			self.write("chan ")
			elemChan, isChan := c.Elem.Kind.(&ast::ChanType)
			if isChan {
				if elemChan.Recv && !elemChan.Send {
					range = true
					self.write("(")
				}
			}
		} else if c.Recv {
			self.write("<-chan ")
		} else {
			self.write("chan<- ")
		}
		self.format(c.Elem.Kind)
		if range {
			self.write(")")
		}
	}

	fn format(self, mut &kind: ast::TypeKind) {
		match type kind {
		| &ast::IdentType:
			self.ident(kind.(&ast::IdentType))
		| &ast::NamespaceType:
			self.namespace(kind.(&ast::NamespaceType))
		| &ast::SptrType:
			self.sptr(kind.(&ast::SptrType))
		| &ast::SliceType:
			self.slice(kind.(&ast::SliceType))
		| &ast::PtrType:
			self.ptr(kind.(&ast::PtrType))
		| &ast::ArrayType:
			self.array(kind.(&ast::ArrayType))
		| &ast::MapType:
			self.mapType(kind.(&ast::MapType))
		| &ast::Func:
			self.fmt.fnDecl(kind.(&ast::Func))
		| &ast::ChanType:
			self.chanType(kind.(&ast::ChanType))
		| &ast::TupleType:
			// no-op
		}
	}
}

// Option flags for scope formatter.
type scopeOption: int

const scopeDefault = 0 << 0
const scopePopByC = 1 << 0 // Pops last comments by row and column.

struct scopeFormatter {
	mut fmt: &formatter
}

impl scopeFormatter {
	fn write(&self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn usexpr(&self, mut u: &ast::UseExpr) {
		self.write("use ")
		self.fmt.formatExpr(u.Expr)
	}

	fn label(&self, l: &ast::Label) {
		// Remove one indentation.
		self.fmt.setBuf(self.fmt.ubuf()[:self.fmt.buf.Len()-self.fmt.indentLen])
		self.write(l.Ident)
		self.write(":")
	}

	fn gotoSt(&self, g: &ast::Goto) {
		self.write("goto ")
		self.write(g.Label.Kind)
	}

	fn fallSt(&self, fll: &ast::Fall) {
		self.write("fall")
	}

	fn contSt(&self, cont: &ast::Continue) {
		self.write("continue")
		if cont.Label != nil {
			self.write(" ")
			self.write(cont.Label.Kind)
		}
	}

	fn breakSt(&self, brk: &ast::Break) {
		self.write("break")
		if brk.Label != nil {
			self.write(" ")
			self.write(brk.Label.Kind)
		}
	}

	fn retSt(&self, mut r: &ast::Ret) {
		self.write("ret")
		if r.Expr != nil {
			self.write(" ")
			self.fmt.formatExpr(r.Expr)
		}
	}

	fn iter(&self, mut it: &ast::Iter) {
		if it.Comptime {
			self.write("const ")
		}
		self.write("for ")
		if !it.IsInf() {
			match type it.Kind {
			| &ast::WhileKind:
				mut wk := it.Kind.(&ast::WhileKind)
				if wk.Expr != nil {
					self.fmt.popRowCommentsByC(wk.Expr.Token.Row, wk.Expr.Token.Column)
					self.fmt.formatExpr(wk.Expr)
				}
				if wk.Next != nil {
					self.write("; ")
					self.formatStmt(wk.Next, scopeDefault)
				}
				self.write(" ")
			| &ast::RangeKind:
				mut rk := it.Kind.(&ast::RangeKind)
				p := (rk.KeyA != nil && rk.KeyA.Mutable) || (rk.KeyB != nil && rk.KeyB.Mutable)
				if p {
					self.write("(")
				}
				if rk.KeyA != nil {
					self.fmt.popRowCommentsByC(rk.KeyA.Token.Row, rk.KeyA.Token.Column)
					if rk.KeyA.Mutable {
						self.write("mut ")
					}
					self.write(rk.KeyA.Ident)
				}
				if rk.KeyB != nil {
					self.write(", ")
					self.fmt.popRowCommentsByC(rk.KeyB.Token.Row, rk.KeyB.Token.Column)
					if rk.KeyB.Mutable {
						self.write("mut ")
					}
					self.write(rk.KeyB.Ident)
				}
				if p {
					self.write(") ")
				} else if rk.KeyA != nil || rk.KeyB != nil {
					self.write(" ")
				}
				self.fmt.popRowCommentsByC(rk.InToken.Row, rk.InToken.Column)
				self.write("in ")
				self.fmt.popRowCommentsByC(rk.Expr.Token.Row, rk.Expr.Token.Column)
				self.fmt.formatExpr(rk.Expr)
				self.write(" ")
			}
		}
		self.write("{")
		self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
			self.write(" ")
			self.fmt.writeComment(c)
		})
		self.write("\n")
		self.fmt.addIndent()
		self.formatStmts(it.Scope, false)
		self.fmt.doneIndent()
		self.fmt.buf.Write(self.fmt.indent)!
		self.write("}")
	}

	fn conditionalCase(&self, mut c: &ast::If) {
		self.write("if ")
		self.fmt.popRowCommentsByC(c.Expr.Token.Row, c.Expr.Token.Column)
		self.fmt.formatExpr(c.Expr)
		self.write(" {")
		self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
			self.write(" ")
			self.fmt.writeComment(c)
		})
		self.write("\n")
		self.fmt.addIndent()
		self.formatStmts(c.Scope, false)
		self.fmt.doneIndent()
		self.fmt.buf.Write(self.fmt.indent)!
		self.write("}")
	}

	fn conditional(&self, mut c: &ast::Conditional) {
		self.conditionalCase(c.Head)
		for (_, mut t) in c.Tail {
			self.write(" ")
			self.fmt.popRowCommentsByC(t.Expr.Token.Row, t.Expr.Token.Column)
			self.write("else ")
			self.conditionalCase(t)
		}
		if c.Default != nil {
			self.write(" ")
			self.fmt.popRowCommentsByC(c.Default.Token.Row, c.Default.Token.Column)
			self.write("else {")
			self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
				self.write(" ")
				self.fmt.writeComment(c)
			})
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Default.Scope, false)
			self.fmt.doneIndent()
			self.fmt.buf.Write(self.fmt.indent)!
			self.write("}")
		}
	}

	fn matchCase(&self, mut mc: &ast::Match) {
		if mc.Comptime {
			self.write("const ")
		}
		self.write("match ")
		if mc.TypeMatch {
			self.write("type ")
		}
		if mc.Expr != nil {
			self.fmt.popRowCommentsByC(mc.Expr.Token.Row, mc.Expr.Token.Column)
			self.fmt.formatExpr(mc.Expr)
			self.write(" ")
		}
		self.write("{\n")
		for (_, mut c) in mc.Cases {
			mut row := c.Exprs[0].Token.Row
			for (i, mut expr) in c.Exprs {
				if row != expr.Token.Row {
					self.fmt.popRowComments(row)
				}
				self.fmt.writeCommentsExcept(expr.Token.Row)
				if row != expr.Token.Row {
					self.write("\n")
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i == 0 {
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i > 0 {
					self.write(" ")
				}
				row = expr.Token.Row
				self.write("| ")
				self.fmt.formatExpr(expr)
			}
			self.write(":")
			self.fmt.popRowComments(self.fmt.row)
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Scope, false)
			self.fmt.doneIndent()
		}
		if mc.Default != nil {
			self.fmt.buf.Write(self.fmt.indent)!
			self.write("|:\n")
			self.fmt.addIndent()
			self.formatStmts(mc.Default.Scope, false)
			self.fmt.doneIndent()
		}

		// Write remaining comments with indentation if
		// any case exist.
		caseExist := len(mc.Cases) > 0 || mc.Default != nil
		if caseExist {
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(mc.End.Row)
		if caseExist {
			self.fmt.doneIndent()
		}

		self.fmt.buf.Write(self.fmt.indent)!
		self.fmt.row = mc.End.Row
		self.write("}")
	}

	fn selectCase(&self, mut slct: &ast::Select) {
		caseExist := len(slct.Cases) > 0 || slct.Default != nil
		if !caseExist {
			// Empty select.
			self.write("select{}")
			ret
		}
		self.write("select {\n")
		for (_, mut c) in slct.Cases {
			mut row := c.Exprs[0].Token.Row
			for (i, mut expr) in c.Exprs {
				if row != expr.Token.Row {
					self.fmt.popRowComments(row)
				}
				self.fmt.writeCommentsExcept(expr.Token.Row)
				if row != expr.Token.Row {
					self.write("\n")
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i == 0 {
					self.fmt.buf.Write(self.fmt.indent)!
				} else if i > 0 {
					self.write(" ")
				}
				row = expr.Token.Row
				self.write("| ")
				self.fmt.formatExpr(expr)
			}
			self.write(":")
			self.fmt.popRowComments(self.fmt.row)
			self.write("\n")
			self.fmt.addIndent()
			self.formatStmts(c.Scope, false)
			self.fmt.doneIndent()
		}
		if slct.Default != nil {
			self.fmt.buf.Write(self.fmt.indent)!
			self.write("|:\n")
			self.fmt.addIndent()
			self.formatStmts(slct.Default.Scope, false)
			self.fmt.doneIndent()
		}

		// Write remaining comments with indentation if
		// any case exist.
		if caseExist {
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(slct.End.Row)
		if caseExist {
			self.fmt.doneIndent()
		}

		self.fmt.buf.Write(self.fmt.indent)!
		self.fmt.row = slct.End.Row
		self.write("}")
	}

	fn postfix(&self, mut &a: &ast::Assign) {
		mut expr := a.Left[0].Expr
		self.fmt.formatExpr(expr)
		self.write(a.Setter.Kind)
	}

	fn singleAssign(&self, mut &a: &ast::Assign) {
		if jule::IsBlank(a.Left[0].Ident) {
			self.write("_ ")
		} else {
			mut expr := a.Left[0].Expr
			self.fmt.formatExpr(expr)
			self.write(" ")
		}
		self.write(a.Setter.Kind)
		self.write(" ")
		self.fmt.formatExpr(a.Right)
	}

	fn multiAssign(&self, mut &a: &ast::Assign) {
		letKwUsed := a.Setter.Id == token::Eq
		if a.Declarative && letKwUsed {
			self.write("let (")
		}
		for (i, mut l) in a.Left {
			if l.Ident != "" {
				if l.Mutable {
					self.write("mut ")
				}
				if l.Reference {
					self.write("&")
				}
			}
			// Do not write range parentheses for expression parts.
			// Expression formatter will add.
			self.fmt.formatExpr(l.Expr)
			if len(a.Left)-i > 1 {
				self.write(", ")
			}
		}
		if a.Declarative {
			if letKwUsed {
				self.write(") = ")
			} else {
				self.write(" := ")
			}
		} else {
			self.write(" = ")
		}
		zip := self.fmt.ef.bf.zip
		_, isTup := a.Right.Kind.(&ast::TupleExpr)
		if isTup {
			self.fmt.ef.bf.zip = len(a.Right.Kind.(&ast::TupleExpr).Expr) > 1
		}
		self.fmt.formatExpr(a.Right)
		self.fmt.ef.bf.zip = zip
	}

	fn assign(&self, mut a: &ast::Assign) {
		match {
		| token::IsPostfixOp(a.Setter.Id):
			self.postfix(a)
		| len(a.Left) == 1 && !a.Declarative:
			self.singleAssign(a)
		|:
			self.multiAssign(a)
		}
	}

	fn formatStmt(&self, mut &stmt: ast::StmtData, options: scopeOption) {
		match type stmt {
		| &ast::Var:
			self.fmt.varDecl(stmt.(&ast::Var), true, [])
		| &ast::TypeAlias:
			self.fmt.typeAliasDecl(stmt.(&ast::TypeAlias))
		| &ast::ScopeTree:
			self.format(stmt.(&ast::ScopeTree), options)
		| &ast::Expr:
			mut expr := stmt.(&ast::Expr)
			self.fmt.formatExpr(expr)
		| &ast::Label:
			self.label(stmt.(&ast::Label))
		| &ast::Goto:
			self.gotoSt(stmt.(&ast::Goto))
		| &ast::UseExpr:
			self.usexpr(stmt.(&ast::UseExpr))
		| &ast::Fall:
			self.fallSt(stmt.(&ast::Fall))
		| &ast::Continue:
			self.contSt(stmt.(&ast::Continue))
		| &ast::Break:
			self.breakSt(stmt.(&ast::Break))
		| &ast::Ret:
			self.retSt(stmt.(&ast::Ret))
		| &ast::Iter:
			self.iter(stmt.(&ast::Iter))
		| &ast::Conditional:
			self.conditional(stmt.(&ast::Conditional))
		| &ast::Match:
			self.matchCase(stmt.(&ast::Match))
		| &ast::Select:
			self.selectCase(stmt.(&ast::Select))
		| &ast::Assign:
			self.assign(stmt.(&ast::Assign))
		}
	}

	fn emptyScope(&self, mut &scope: &ast::ScopeTree) {
		// Lookup for first comment.
		c := self.fmt.seekCommentExcept(scope.End.Row)

		// Range comment exist and scope is not indented.
		// Indent scope if indent is true.
		indent := unsafe { self.fmt.buf.Buf()[self.fmt.buf.Len()-1] } != '\n' &&
			c != nil && c.txt[1] == '*'

		if indent {
			self.write("\n")
			self.fmt.addIndent()
		}
		self.fmt.writeCommentsExcept(scope.End.Row)
		if indent {
			self.fmt.doneIndent()
			self.fmt.buf.Write(self.fmt.indent)!
		}
	}

	fn formatStmts(&self, mut &scope: &ast::ScopeTree, inline: bool) {
		defer {
			self.fmt.row = scope.End.Row
		}

		if len(scope.Stmts) == 0 {
			self.emptyScope(scope)
			ret
		}

		mut i := 0
		self.fmt.row = scope.Stmts[0].Token.Row
		mut z := i
		for i < len(scope.Stmts); i++ {
			mut stmt := scope.Stmts[i]
			if i > 0 {
				self.write("\n")
			}
			z = self.fmt.row
			self.fmt.addGlobalPaddingForComment(stmt.Token.Row - 1) // Use -1 row for avoid inline comments.
			self.fmt.row = self.fmt.writeCommentsExcept(stmt.Token.Row)
			if stmt.Token.Row-self.fmt.row == 0 {
				self.fmt.row = z
			}
			if stmt.Token.Row-self.fmt.row > 1 {
				self.write("\n")
			}
			z = i
			self.fmt.row = stmt.Token.Row
			if !inline && isGroupStmt(stmt) {
				self.fmt.groupDecls[ast::Stmt, ast::Stmt](scope.Stmts, i, fn(mut &d: ast::Stmt) {
					self.fmt.buf.Write(self.fmt.indent)!
					self.formatStmt(d.Data, scopeDefault)
				})
			} else {
				if !inline {
					self.fmt.buf.Write(self.fmt.indent)!
				}
				self.formatStmt(stmt.Data, scopeDefault)
				if !inline {
					self.fmt.popRowComments(self.fmt.row)
				} else {
					self.fmt.popRowCommentsByF(self.fmt.row, scope.End.Column, fn(c: &comment) {
						self.write(" ")
						self.fmt.writeComment(c)
					})
				}
			}
			if z != i {
				i--
				self.fmt.setBuf(self.fmt.ubuf()[:self.fmt.buf.Len()-1])
			}
		}
		i = self.fmt.buf.Len() - 1
		for i >= 0; i-- {
			if self.fmt.ubuf()[i] != '\n' {
				self.fmt.setBuf(self.fmt.ubuf()[:i+1])
				self.write("\n")
				break
			}
		}

		self.fmt.writeCommentsExcept(scope.End.Row)
	}

	fn format(&self, mut scope: &ast::ScopeTree, options: scopeOption) {
		if scope.Unsafety {
			self.write("unsafe ")
		}
		if scope.Deferred {
			self.write("defer ")
		}
		self.write("{")
		n := self.fmt.buf.Len()
		comment := false   // Whether comment written and indented.
		commentWr := false // Whether comment written.
		{
			mut commentPtr := unsafe { (&bool)(&comment) }
			mut commentWrPtr := unsafe { (&bool)(&commentWr) }
			writer := fn(c: &comment) {
				*commentWrPtr = true
				match {
				| c.txt[1] == '/':
					if !*commentPtr {
						self.fmt.addIndent()
					}
					self.write("\n")
					self.fmt.buf.Write(self.fmt.indent)!
					*commentPtr = true
				| c.txt[1] == '*':
					if strings::ContainsRune(c.txt, '\n') {
						if !*commentPtr {
							self.fmt.addIndent()
						}
						self.write("\n")
						self.fmt.buf.Write(self.fmt.indent)!
						*commentPtr = true
						break
					}
					fall
				| !*commentPtr:
					self.write(" ")
				}
				self.fmt.writeComment(c)
			}
			if len(scope.Stmts) > 0 && scope.Stmts[0].Token.Row == scope.End.Row {
				self.fmt.popRowCommentsByF(self.fmt.row, scope.Stmts[0].Token.Column, writer)
			} else if len(scope.Stmts) == 0 {
				self.fmt.row = scope.End.Row
				self.fmt.popRowCommentsUntilByF(self.fmt.row-1, -1, writer)
				self.fmt.popRowCommentsByF(self.fmt.row, scope.End.Column, writer)
			}
			if comment {
				// Comment(s) written with new-line.
				// So we have to convert space-indentation to indented new-line.
				mut buf := self.fmt.ubuf()
				if buf[n] != '\n' {
					buf[n] = '\n'
					buf = slices::Insert(buf, n+1, self.fmt.indent...)
				}
			}
		}
		inline := (len(scope.Stmts) == 0 && !comment) ||
			(len(scope.Stmts) == 1 &&
				self.fmt.row == scope.End.Row &&
				scope.Stmts[0].Token.Row == scope.End.Row)
		if inline {
			if len(scope.Stmts) > 0 || commentWr {
				self.write(" ")
			}
		} else {
			self.write("\n")
			if !comment {
				self.fmt.addIndent()
			}
		}

		// save internal state of binary formatter
		zip := self.fmt.ef.bf.zip
		op := self.fmt.ef.bf.op
		prec := self.fmt.ef.bf.prec

		// reset internal state of binary formatter
		// thus we can use new internal state for anonymous functions or exceptional handlers
		self.fmt.ef.bf.clean()

		self.formatStmts(scope, inline)

		// save internal state of binary formatter
		self.fmt.ef.bf.zip = zip
		self.fmt.ef.bf.op = op
		self.fmt.ef.bf.prec = prec

		if !inline {
			self.fmt.doneIndent()
		}
		if inline {
			if len(scope.Stmts) > 0 {
				self.fmt.ubuf()[self.fmt.buf.Len()-1] = ' '
			}
		} else if n == self.fmt.buf.Len() {
			self.fmt.setBuf(self.fmt.ubuf()[:n-1])
		} else {
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write("}")
		if options&scopePopByC == scopePopByC {
			self.fmt.popRowCommentsByC(scope.End.Row, scope.End.Column)
		} else {
			self.fmt.popRowComments(scope.End.Row)
		}
		self.fmt.row = scope.End.Row
	}
}

struct exprFormatter {
	mut fmt: &formatter
	mut bf:  &binaryFormatter

	// Ignore begin comments.
	// It will skips comments for begin.
	// Useful for slice literal elements.
	mut ibc: bool
}

impl exprFormatter {
	static fn new(&fmt: &formatter): &exprFormatter {
		mut ef := &exprFormatter{
			fmt: unsafe { *(&fmt) },
		}
		ef.bf = &binaryFormatter{
			ef: ef,
		}
		ret ef
	}

	fn write(&self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn clean(&self) {
		self.bf.clean()
	}

	fn tuple(&self, mut tup: &ast::TupleExpr) {
		for (i, mut expr) in tup.Expr {
			self.format(expr)
			if i+1 < len(tup.Expr) {
				self.write(", ")
			}
		}
	}

	fn lit(&self, l: &ast::LitExpr) {
		self.write(l.Value)
	}

	fn unsafexpr(&self, mut u: &ast::UnsafeExpr) {
		self.write("unsafe {")
		line := u.Expr.Token.Row != u.Expr.End.Row
		if line {
			self.fmt.addIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.format(u.Expr)
		if line {
			self.fmt.doneIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.write("}")
	}

	fn ident(&self, id: &ast::IdentExpr) {
		if id.Binded {
			self.write("cpp.")
		}
		self.write(id.Ident)
	}

	fn unary(&self, mut u: &ast::UnaryExpr) {
		self.write(u.Op.Kind)
		self.format(u.Expr)
	}

	fn variadic(&self, mut v: &ast::VariadicExpr) {
		self.format(v.Expr)
		self.write("...")
	}

	fn cast(&self, mut c: &ast::CastExpr) {
		if isPrimType(c.Kind) {
			self.fmt.formatType(c.Kind)
		} else {
			self.write("(")
			self.fmt.formatType(c.Kind)
			self.write(")")
		}
		self.write("(")
		self.format(c.Expr)
		self.write(")")
	}

	fn namespace(&self, ns: &ast::NamespaceExpr) {
		self.write(ns.Namespace.Kind)
		self.write("::")
		self.write(ns.Ident.Kind)
	}

	fn subIdent(&self, mut si: &ast::SubIdentExpr) {
		self.format(si.Expr)
		self.write(".")
		self.write(si.Ident.Kind)
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bf.new(bin)
		self.bf.binary(bin)
	}

	fn args(&self, mut &f: &ast::FuncCallExpr) {
		if len(f.Args) == 0 {
			ret
		}

		// save state of zip mode
		zip := self.bf.zip
		self.bf.zip = self.bf.zip || len(f.Args) > 1 // enable zip mode if arguments more than one

		mut row := f.Token.Row
		mut indented := false
		for (i, mut arg) in f.Args {
			if i > 0 {
				self.write(",")
			}
			if row != arg.Token.Row {
				if !indented {
					indented = true
					self.fmt.addIndent()
				}
				const Pad = true
				self.fmt.writeCommentsExceptL(arg.Token.Row, arg.Token.Row, Pad)
				self.write("\n")
				self.fmt.buf.Write(self.fmt.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column)
			self.format(arg)
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column)
			row = self.fmt.row
		}
		if indented {
			self.fmt.doneIndent()
		}

		// save zip mode
		self.bf.zip = zip
	}

	fn fnCall(&self, mut f: &ast::FuncCallExpr) {
		if f.IsCo {
			self.write("co ")
		}
		self.format(f.Expr)
		self.write("(")
		self.args(f)
		self.write(")")
		if f.Ignored() {
			self.write("!")
		} else if f.Exception != nil {
			self.write(" else ")
			self.fmt.formatScope(f.Exception, scopeDefault)
			self.fmt.row = f.Exception.End.Row
		}
	}

	fn fieldExprPair(&self, mut pair: &ast::FieldExprPair) {
		if pair.IsTargeted() {
			self.write(pair.Field.Kind)
			self.write(": ")
		}
		self.format(pair.Expr)
	}

	fn typedBraceLit(&self, mut lit: &ast::TypedBraceLit) {
		self.fmt.formatType(lit.Kind)
		if len(lit.Lit.Exprs) == 0 {
			self.write("{}")
			self.fmt.row = lit.Lit.End.Row
			ret
		}
		mut newline := false
		for _, expr in lit.Lit.Exprs {
			// Compare with kind row. Because kind and brace should be same line.
			// Therefore, kind row also means brace row.
			if expr.Token.Row != lit.Kind.Token.Row {
				newline = true
				break
			}
		}
		self.write("{")
		if newline {
			self.write("\n")
		}
		self.fmt.addIndent()
		for (i, mut expr) in lit.Lit.Exprs {
			diff := len(lit.Lit.Exprs) - i
			if newline {
				if !self.ibc {
					self.fmt.addGlobalPaddingForComment(expr.Token.Row)
					const Pad = true
					self.fmt.writeCommentsExceptL(expr.Token.Row-1, expr.Token.Row, Pad)
				}
				self.fmt.buf.Write(self.fmt.indent)!
			}
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)
			self.format(expr)
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)
			if newline {
				self.write(",")
				if diff < 2 || lit.Lit.Exprs[i+1].Token.Row != self.fmt.row {
					self.fmt.popRowCommentsByF(self.fmt.row, -1, fn(c: &comment) {
						self.write(" ")
						self.fmt.writeComment(c)
					})
				}
				self.write("\n")
			} else if diff > 1 {
				self.write(", ")
			}
		}
		if !self.ibc {
			self.fmt.addGlobalPaddingForComment(lit.Lit.End.Row)
			const Pad = true
			self.fmt.writeCommentsExceptL(lit.Lit.End.Row, lit.Lit.End.Row, Pad)
		}
		self.fmt.doneIndent()
		if newline {
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write("}")
		self.fmt.row = lit.Lit.End.Row
	}

	fn responsiveExprs[T](&self, mut &lit: T) {
		if len(lit.Exprs) == 0 {
			ret
		}
		const Cap = 1 << 8
		mut exprs := make([][]byte, 0, Cap)
		mut rows := make([]rowAlign, 0, Cap)

		old := self.ibc
		self.ibc = true
		mut sibc := !old // self.ibc setted to true by this routine.

		n := self.fmt.buf.Len()
		mut max := 0
		mut col := 0
		mut row := lit.Token.Row
		mut lined := false

		self.fmt.addIndent()
		for (i, mut expr) in lit.Exprs {
			if row != expr.Token.Row {
				lined = true
				mut line := cloneBuf(self.fmt.ubuf()[n:])
				diff := utf8::RuneCount(line)
				if diff > 0 {
					if max < diff && self.fmt.row == row {
						max = diff
					}
					exprs = append(exprs, line)
					self.fmt.setBuf(self.fmt.ubuf()[:n])
					rows = append(rows, rowAlign{
						end: expr.Token.Row,
						row: self.fmt.row,
						col: col,
						max: self.fmt.row == row,
					})
				}
			} else if i > 0 {
				self.write(" ")
			}
			self.fmt.popRowCommentsByC(expr.Token.Row, expr.Token.Column)
			self.format(expr)
			row = expr.Token.Row
			col = expr.End.Column
			if lined || len(lit.Exprs)-i > 1 {
				self.write(",")
			}
		}
		if n != self.fmt.buf.Len() {
			mut line := cloneBuf(self.fmt.ubuf()[n:])
			diff := utf8::RuneCount(line)
			if max < diff && self.fmt.row == row {
				max = diff
			}
			exprs = append(exprs, line)
			rows = append(rows, rowAlign{
				end: row,
				row: self.fmt.row,
				max: self.fmt.row == row,
			})
			self.fmt.setBuf(self.fmt.ubuf()[:n])
		}

		fmtRow := self.fmt.row
		defer {
			self.fmt.row = fmtRow
		}
		if lit.Token.Row != lit.Exprs[0].Token.Row {
			self.write("\n")
		}
		self.fmt.row = rows[0].row
		for i, expr in exprs {
			erow := rows[i]
			if !self.ibc || sibc || lined {
				self.fmt.addGlobalPaddingForCommentL(lit.Token.Row, erow.row)
				const Pad = true
				self.fmt.writeCommentsExceptL(lit.Token.Row, erow.row, Pad)
			}
			if self.fmt.ubuf()[self.fmt.buf.Len()-1] == '\n' {
				self.fmt.buf.Write(self.fmt.indent)!
			}
			col = erow.col
			if lined {
				col = -1
			}
			self.fmt.buf.Write(expr)!
			self.fmt.popRowCommentsByF(erow.row, col, fn(c: &comment) {
				if erow.max {
					self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(expr))+1))
				} else {
					self.write(" ")
				}
				self.fmt.writeComment(c)
			})
			if len(exprs)-i > 1 {
				self.write("\n")
			}
			self.fmt.row = erow.row
		}
		if self.fmt.ubuf()[self.fmt.buf.Len()-1] != '\n' && lined {
			self.write("\n")
		}
		if !self.ibc || sibc || lined {
			self.fmt.addGlobalPaddingForCommentL(lit.Token.Row, lit.End.Row)
			const Pad = true
			self.fmt.writeCommentsExceptL(lit.Token.Row, lit.End.Row, Pad)
		}
		self.fmt.doneIndent()
		if lined {
			self.fmt.buf.Write(self.fmt.indent)!
		}

		self.ibc = old
	}

	fn braceLit(&self, mut lit: &ast::BraceLit) {
		self.write("{")
		self.responsiveExprs[&ast::BraceLit](lit)
		self.write("}")
	}

	fn keyValPair(&self, mut pair: &ast::KeyValPair) {
		self.format(pair.Key)
		self.write(": ")
		self.format(pair.Val)
	}

	fn slice(&self, mut s: &ast::SliceExpr) {
		self.write("[")
		self.responsiveExprs[&ast::SliceExpr](s)
		self.write("]")
	}

	fn indexing(&self, mut i: &ast::IndexingExpr) {
		self.format(i.Expr)
		self.write("[")

		zip := self.bf.zip
		self.bf.zip = true
		self.format(i.Index)
		self.bf.zip = zip

		self.write("]")
	}

	fn slicing(&self, mut i: &ast::SlicingExpr) {
		zip := self.bf.zip
		defer { self.bf.zip = zip }

		mut lb, mut rb, mut cb := false, false, false
		lr, rr, cr := isRanged(i.Start), isRanged(i.To), isRanged(i.Cap)
		if !lr && i.Start != nil {
			_, isBinary := i.Start.Kind.(&ast::BinaryExpr)
			if isBinary {
				lb = true
			}
		}
		if !rr && i.To != nil {
			_, isBinary := i.To.Kind.(&ast::BinaryExpr)
			if isBinary {
				rb = true
			}
		}
		if !cr && i.Cap != nil {
			_, isBinary := i.Cap.Kind.(&ast::BinaryExpr)
			if isBinary {
				cb = true
			}
		}

		self.format(i.Expr)
		self.write("[")

		self.bf.zip = zip || !lr
		self.format(i.Start)

		padding := !zip && (lb || rb || cb)
		if padding && i.Start != nil && i.To != nil {
			self.write(" : ")
		} else if padding && i.Start == nil && i.Cap != nil {
			self.write(": ")
		} else {
			self.write(":")
		}

		self.bf.zip = zip || !rr
		self.format(i.To)

		if i.Cap != nil {
			if padding {
				self.write(" : ")
			} else {
				self.write(":")
			}
			self.bf.zip = zip || !cr
			self.format(i.Cap)
		}

		self.write("]")
	}

	fn chanRecv(&self, mut c: &ast::ChanRecv) {
		self.write("<-")
		self.format(c.Expr)
	}

	fn chanSend(&self, mut c: &ast::ChanSend) {
		self.fmt.formatExpr(c.Chan)
		self.write(" <- ")
		self.fmt.formatExpr(c.Data)
	}

	fn typeAssertion(&self, mut a: &ast::TypeAssertionExpr) {
		self.fmt.formatExpr(a.Expr)
		self.write(".(")
		self.fmt.formatType(a.Kind)
		self.write(")")
	}

	fn formatKind(&self, mut &kind: ast::ExprData) {
		match type kind {
		| &ast::RangeExpr:
			mut expr := kind.(&ast::RangeExpr)
			self.write("(")
			self.formatKind(expr.Expr.Kind)
			self.write(")")
		| &ast::Type:
			mut t := kind.(&ast::Type)
			self.fmt.formatType(t)
		| &ast::Func:
			self.fmt.fnDecl(kind.(&ast::Func))
		| &ast::IdentExpr:
			self.ident(kind.(&ast::IdentExpr))
		| &ast::TupleExpr:
			self.tuple(kind.(&ast::TupleExpr))
		| &ast::LitExpr:
			self.lit(kind.(&ast::LitExpr))
		| &ast::UnsafeExpr:
			self.unsafexpr(kind.(&ast::UnsafeExpr))
		| &ast::UnaryExpr:
			self.unary(kind.(&ast::UnaryExpr))
		| &ast::VariadicExpr:
			self.variadic(kind.(&ast::VariadicExpr))
		| &ast::CastExpr:
			self.cast(kind.(&ast::CastExpr))
		| &ast::NamespaceExpr:
			self.namespace(kind.(&ast::NamespaceExpr))
		| &ast::SubIdentExpr:
			self.subIdent(kind.(&ast::SubIdentExpr))
		| &ast::BinaryExpr:
			self.binary(kind.(&ast::BinaryExpr))
		| &ast::FuncCallExpr:
			self.fnCall(kind.(&ast::FuncCallExpr))
		| &ast::FieldExprPair:
			self.fieldExprPair(kind.(&ast::FieldExprPair))
		| &ast::TypedBraceLit:
			self.typedBraceLit(kind.(&ast::TypedBraceLit))
		| &ast::BraceLit:
			self.braceLit(kind.(&ast::BraceLit))
		| &ast::KeyValPair:
			self.keyValPair(kind.(&ast::KeyValPair))
		| &ast::SliceExpr:
			self.slice(kind.(&ast::SliceExpr))
		| &ast::IndexingExpr:
			self.indexing(kind.(&ast::IndexingExpr))
		| &ast::SlicingExpr:
			self.slicing(kind.(&ast::SlicingExpr))
		| &ast::ChanRecv:
			self.chanRecv(kind.(&ast::ChanRecv))
		| &ast::ChanSend:
			self.chanSend(kind.(&ast::ChanSend))
		| &ast::TypeAssertionExpr:
			self.typeAssertion(kind.(&ast::TypeAssertionExpr))
		}
	}

	fn format(&self, mut &expr: &ast::Expr) {
		if expr == nil {
			ret
		}
		self.fmt.row = expr.Token.Row
		self.formatKind(expr.Kind)
		self.fmt.row = expr.End.Row
	}
}

struct binaryFormatter {
	mut ef:   &exprFormatter
	mut zip:  bool
	mut op:   bool // result of [binaryFormatter.isOp]
	mut prec: bool // spacing by operator format precedence
	mut bin:  &ast::BinaryExpr
}

impl binaryFormatter {
	// Reports whether operator should take space for formatting.
	static fn isOp(op: int): bool {
		ret op == token::DblVline ||
			op == token::DblAmper ||
			op == token::Gt ||
			op == token::Lt ||
			op == token::LtEq ||
			op == token::GtEq ||
			op == token::DblEq ||
			op == token::NotEq
	}

	// Reports whether the operator is have high formatting precedence.
	// Returns 1 for high precedence, otherwise returns 0.
	static fn opPrec(op: int): int {
		match op {
		| token::Shl
		| token::Shr
		| token::Star
		| token::Solidus
		| token::Percent
		| token::Amper:
			ret 1
		|:
			ret 0
		}
	}

	// Reports whether operator zips operands.
	static fn isHardZipOp(op: int): bool {
		ret op == token::DblVline ||
			op == token::DblAmper
	}

	fn write(&self, s: str) {
		self.ef.write(s)
	}

	fn clean(&self) {
		self.zip = false
		self.op = false
		self.prec = false
		self.bin = nil
	}

	// writes space for operator if possible
	fn writeSpace(&self) {
		if self.op {
			self.write(" ")
			ret
		}
		// operator is not op

		if self.zip {
			// zip mode on following detection is disallowed
			ret
		}
		// zip mode is off

		if !self.prec {
			// prec mode is off
			self.write(" ")
			ret
		}
		// prec mode is on

		// write space if operator is not precedenced
		if binaryFormatter.opPrec(self.bin.Op.Id) == 0 {
			self.write(" ")
		}
	}

	fn head(&self, mut &bin: &ast::BinaryExpr) {
		self.ef.fmt.popRowCommentsByC(bin.Left.Token.Row, bin.Left.Token.Column)
		self.format(bin.Left)
		self.op = binaryFormatter.isOp(bin.Op.Id)
		self.writeSpace()
		self.ef.fmt.popRowCommentsByC(bin.Op.Row, bin.Op.Column)
		self.write(bin.Op.Kind)
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bin = bin
		self.head(self.bin)
		if self.bin.Op.Row == self.bin.Right.Token.Row {
			self.writeSpace()
			self.ef.fmt.popRowCommentsByC(self.bin.Right.Token.Row, self.bin.Right.Token.Column)
			self.format(self.bin.Right)
			ret
		}
		self.ef.fmt.addIndent()
		self.ef.fmt.popRowCommentsBy(self.bin.Op.Row)
		self.write("\n")
		self.ef.fmt.buf.Write(self.ef.fmt.indent)!
		self.ef.fmt.popRowCommentsByC(self.bin.Right.Token.Row, self.bin.Right.Token.Column)
		match type self.bin.Right.Kind {
		| &ast::BinaryExpr:
			bin = self.bin.Right.Kind.(&ast::BinaryExpr)
			if self.bin.Op.Row != self.bin.Right.Token.Row {
				self.binary(bin)
				self.ef.fmt.doneIndent()
			} else {
				self.ef.fmt.doneIndent()
				self.binary(bin)
			}
		|:
			self.format(self.bin.Right)
			self.ef.fmt.row = self.bin.Right.Token.Row
			self.ef.fmt.doneIndent()
		}
	}

	fn isZip(&self, mut &kind: ast::ExprData): bool {
		match type kind {
		| &ast::BinaryExpr:
			mut bin := kind.(&ast::BinaryExpr)
			if binaryFormatter.isHardZipOp(bin.Op.Id) {
				ret true
			}
			ret self.isZip(bin.Left.Kind) || self.isZip(bin.Right.Kind)
		|:
			ret false
		}
	}

	fn isPrec(&self, first: int, &kind: ast::ExprData): int {
		match type kind {
		| &ast::BinaryExpr:
			bin := kind.(&ast::BinaryExpr)
			if first != binaryFormatter.opPrec(bin.Op.Id) {
				ret -1
			}
			mut prec := self.isPrec(first, bin.Left.Kind)
			if first != prec {
				ret -1
			}
			prec = self.isPrec(first, bin.Right.Kind)
			if first != prec {
				ret -1
			}
			ret first
		|:
			ret first
		}
	}

	fn new(&self, mut &bin: &ast::BinaryExpr) {
		if self.zip {
			ret
		}
		// detect zip
		if binaryFormatter.isOp(bin.Op.Id) {
			self.zip = true
			ret
		}
		self.zip = self.isZip(bin.Left.Kind) || self.isZip(bin.Right.Kind)
		if self.zip {
			// skip if zipped, no need to detect following
			ret
		}

		// detect prec
		if !self.prec {
			// enable prec formatting if all operators is not have same prec
			first := binaryFormatter.opPrec(bin.Op.Id)
			self.prec = first != self.isPrec(first, bin.Left.Kind) || first != self.isPrec(first, bin.Right.Kind)
		}
	}

	// Formats expression.
	// It designed for binary expressions operands only.
	fn format(&self, mut &expr: &ast::Expr) {
		if expr == nil {
			ret
		}

		// store state of internal data
		zip := self.zip
		prec := self.prec
		mut bin := self.bin

		// format expression
		match type expr.Kind {
		| &ast::BinaryExpr:
			// keep prec mode for tail
			break
		| &ast::FuncCallExpr
		| &ast::CastExpr:
			self.zip = true

			// disable prec mode for non-tail expressions
			self.prec = false
		|:
			// enable zip mode if prec mode is enabled and
			// current binary operator have high precedence
			self.zip = self.zip || self.prec && binaryFormatter.opPrec(self.bin.Op.Id) == 1

			// disable prec mode for non-tail expressions
			self.prec = false
		}
		self.ef.format(expr)

		// save internal data
		self.zip = zip
		self.bin = bin
		self.prec = prec
	}
}

fn paddingAbs(x: int): int {
	if x < 0 {
		ret 0
	}
	ret x
}

fn isPrimType(&t: &ast::Type): bool {
	name, ok := t.Kind.(&ast::IdentType)
	ret ok && (name.Ident == types::I8 ||
		name.Ident == types::I16 ||
		name.Ident == types::I32 ||
		name.Ident == types::I64 ||
		name.Ident == types::U8 ||
		name.Ident == types::U16 ||
		name.Ident == types::U32 ||
		name.Ident == types::U64 ||
		name.Ident == types::Int ||
		name.Ident == types::Uint ||
		name.Ident == types::Uintptr ||
		name.Ident == types::F32 ||
		name.Ident == types::F64 ||
		name.Ident == types::Bool ||
		name.Ident == types::Str ||
		name.Ident == types::Any)
}

fn isRanged(&e: &ast::Expr): bool {
	if e == nil {
		ret false
	}
	_, ok := e.Kind.(&ast::RangeExpr)
	ret ok
}

fn isEmptyImpl(&imp: &ast::Impl): bool {
	ret len(imp.Methods) == 0
}

fn cloneBuf(b: []byte): []byte {
	mut rb := make([]byte, len(b))
	copy(rb, b)
	ret rb
}

fn isGroupStmt(stmt: ast::Stmt): bool {
	match type stmt.Data {
	| &ast::TypeAlias
	| &ast::Var
	| &ast::Assign
	| &ast::Expr:
		ret true
	|:
		ret false
	}
}

fn indexRowBrake(rows: []int): int {
	for i, r in rows {
		if i > 0 && r-rows[i-1] > 1 {
			ret i
		}
	}
	ret len(rows)
}