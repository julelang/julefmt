// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast::{
    Ast,
}
use lex for std::jule::lex::{
    Token,
    TokenKind,
}
use strings for std::strings

struct Formatter {
    mut buf:    str
    mut f:      &Ast
    mut indent: str
    mut cm:     CommentMap
}

impl Formatter {
    static fn new(): &Formatter {
        ret new(Formatter)
    }

    fn write(&self, s: str) {
        self.buf += s
    }

    fn add_indent(&self) {
        self.indent += "    "
    }

    fn done_indent(&self) {
        self.indent = self.indent[:self.indent.len - 4]
    }

    fn write_comments(&self, row: int) {
        for {
            let mut c = self.cm.pop(row)
            if c == nil {
                break
            }
            self.write(self.indent)
            self.write(c.txt)
            self.write("\n")
        }
    }

    fn format_expr(&self, &expr: &ast::Expr) {
        let ef = ExprFormatter{
            fmt: self,
        }
        ef.format(expr.kind)
    }

    fn format_type(&self, &expr: &ast::TypeDecl) {
        let tf = TypeFormatter{
            fmt: self,
        }
        tf.format(expr.kind)
    }

    fn directive(&self, &d: &ast::Directive) {
        self.write("#")
        self.write(d.tag.kind)
        for i, arg in d.args {
            match {
            | i == 0:
                self.write(" ")
            | arg.kind != TokenKind.RParent && d.args[i - 1].kind != TokenKind.LParent:
                self.write(" ")
            }
            self.write(arg.kind)
        }
    }

    fn directives(&self, dvs: []&ast::Directive) {
        for i, d in dvs {
            self.directive(d)
            if i + 1 < dvs.len {
                self.write("\n")
                self.write(self.indent)
            }
        }
    }

    fn use_decl(&self, d: &ast::UseDecl) {
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write("use ")
        if d.alias != "" {
            self.write(d.alias)
            self.write(" for ")
        }
        if d.cpp_linked {
            self.write("\"")
            self.write(d.link_path)
            self.write("\"")
        } else {
            self.write(d.link_path)
        }
        if d.full {
            self.write("::*")
            ret
        }
        if d.selected.len == 0 {
            ret
        }
        self.write("::{\n")
        for _, s in d.selected {
            self.write("    ")
            self.write(s.kind)
            self.write(",\n")
        }
        self.write("}")
    }

    fn use_decls(&self) {
        if self.f.use_decls.len == 0 {
            ret
        }
        self.write("\n")
        for _, decl in self.f.use_decls {
            self.write("\n")
            self.write_comments(decl.token.row)
            self.use_decl(decl)
        }
    }

    fn generics(&self, &g: []&ast::GenericDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for i, t in g {
            self.write(t.ident)
            if i + 1 < g.len {
                self.write(", ")
            }
        }
        self.write("]")
    }

    fn enum_decl(&self, mut d: &ast::EnumDecl) {
        if d.public {
            self.write("pub ")
        }
        self.write("enum ")
        self.write(d.ident)
        if !d.default_typed() {
            self.write(": ")
            self.format_type(d.kind)
        }
        self.write(" {\n")
        self.add_indent()
        for _, item in d.items {
            self.write_comments(item.token.row)
            self.write(self.indent)
            self.write(item.ident)
            if !item.auto_expr() {
                self.write(" = ")
                self.format_expr(item.expr)
            }
            self.write(",\n")
        }
        self.write("}")
        self.done_indent()
    }

    fn fn_decl(&self, mut d: &ast::FnDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
            self.write(self.indent)
        }
        if d.public {
            self.write("pub ")
        }
        if d.statically {
            self.write("static ")
        }
        self.write("fn ")
        self.write(d.ident)
        self.generics(d.generics)
        self.write("(")
        for i, p in d.params {
            if p.mutable {
                self.write("mut ")
            }
            if p.reference {
                self.write("&")
            }
            if p.is_self() {
                self.buf += "self"
            } else {
                if !lex::is_anon_ident(p.ident) {
                    self.write(p.ident)
                    self.write(": ")
                } else if p.reference {
                    self.write("_: ")
                }
                self.format_type(p.kind)
            }
            if i + 1 < d.params.len {
                self.write(", ")
            }
        }
        self.write(")")
        // SCOPE
    }

    fn fields(&self, &fields: []&ast::FieldDecl, public: bool, mutable: bool, n: int) {
        for _, f in fields {
            if f.public != public || f.mutable != mutable {
                continue
            }
            self.write(self.indent)
            if f.public {
                self.buf += "pub "
            }
            if f.mutable {
                self.buf += "mut "
            }
            self.write(f.ident)
            self.write(": ")
            let diff = n - f.ident.len
            if diff > 0 {
                self.write(strings::repeat(" ", diff))
            }
            self.format_type(f.kind)
            self.write("\n")
        }
    }

    fn struct_decl(&self, mut d: &ast::StructDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.public {
            self.buf += "pub "
        }
        if d.cpp_linked {
            self.buf += "cpp "
        }
        self.buf += "struct "
        self.buf += d.ident
        self.generics(d.generics)
        if d.fields.len == 0 {
            self.buf += " {}"
            ret
        }
        let (p, pm, pb, pbm) = max_field_len(d.fields)
        _ = pm, pb, pbm
        self.buf += " {\n"
        self.add_indent()
        if p > 0 {
            self.fields(d.fields, false, false, p)
        }
        if pm > 0 {
            if p > 0 {
                self.write("\n")
            }
            self.fields(d.fields, false, true, pm)
        }
        if pb > 0 {
            if pm > 0 {
                self.write("\n")
            }
            self.fields(d.fields, true, false, pb)
        }
        if pbm > 0 {
            if pb > 0 {
                self.write("\n")
            }
            self.fields(d.fields, true, true, pbm)
        }
        self.done_indent()
        self.buf += "}"
    }

    fn trait_decl(&self, mut d: &ast::TraitDecl) {
        if d.public {
            self.buf += "pub "
        }
        self.buf += d.ident
        if d.methods.len == 0 {
            self.buf += " {}"
            ret
        }
        self.buf += " {"
        self.add_indent()
        for (_, mut m) in d.methods {
            self.write("\n")
            self.write_comments(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.write("\n")
        }
        self.done_indent()
        self.buf += "}"
    }

    fn type_alias_decl(&self, mut d: &ast::TypeAliasDecl) {
        if d.public {
            self.write("pub ")
        }
        if d.cpp_linked {
            self.write("cpp ")
        }
        self.write(d.ident)
        self.write(": ")
        self.format_type(d.kind)
    }

    fn var_decl(&self, mut d: &ast::VarDecl) {
        if d.directives.len != 0 {
            self.directives(d.directives)
            self.write("\n")
        }
        if d.cpp_linked {
            self.write("cpp let ")
        } else {
            if d.public {
                self.write("pub ")
            }
            if d.statically {
                self.write("static ")
            }
            if d.constant {
                self.write("const ")
            }
        }
        if d.mutable {
            self.write("mut ")
        }
        if d.reference {
            self.write("&")
        }
        self.write(d.ident)
        if d.kind != nil {
            self.write(": ")
            self.format_type(d.kind)
        }
        if d.expr != nil {
            self.write(" = ")
            self.format_expr(d.expr)
        }
    }

    fn impl_decl(&self, mut d: &ast::Impl) {
        self.write("impl ")
        if d.is_trait_impl() {
            self.format_type(d.base)
            self.write(" for ")
        }
        self.format_type(d.dest)
        if d.methods.len == 0 && d.statics.len == 0 {
            self.write(" {}")
            ret
        }
        self.buf += " {\n"
        self.add_indent()
        for (_, mut s) in d.statics {
            self.write_comments(s.token.row)
            self.write(self.indent)
            self.var_decl(s)
            self.write("\n")
        }
        for (_, mut m) in d.methods {
            self.write("\n")
            self.write_comments(m.token.row)
            self.write(self.indent)
            self.fn_decl(m)
            self.write("\n")
        }
        self.done_indent()
        self.write("}")
    }

    fn node(&self, mut &node: ast::Node) {
        match type node.data {
        | &ast::EnumDecl:
            self.enum_decl((&ast::EnumDecl)(node.data))
        | &ast::FnDecl:
            self.fn_decl((&ast::FnDecl)(node.data))
        | &ast::StructDecl:
            self.struct_decl((&ast::StructDecl)(node.data))
        | &ast::TraitDecl:
            self.trait_decl((&ast::TraitDecl)(node.data))
        | &ast::TypeAliasDecl:
            self.type_alias_decl((&ast::TypeAliasDecl)(node.data))
        | &ast::VarDecl:
            self.var_decl((&ast::VarDecl)(node.data))
        | &ast::Impl:
            self.impl_decl((&ast::Impl)(node.data))
        }
    }

    fn nodes(&self) {
        for (_, mut node) in self.f.nodes {
            self.write("\n\n")
            self.write_comments(node.token.row)
            self.node(node)
            self.write("\n")
        }
    }

    fn format(&self, mut &f: &Ast, mut &cm: CommentMap): str {
        self.cm = cm
        self.f = f
        self.directives(self.f.top_directives)
        self.use_decls()
        self.nodes()
        self.f = nil
        ret strings::trim(self.buf, " \n\r\v\t")
    }
}

struct TypeFormatter {
    mut fmt: &Formatter
    mut buf: str
}

impl TypeFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn generics(self, g: []&ast::TypeDecl) {
        if g.len == 0 {
            ret
        }
        self.write("[")
        for i, t in g {
            self.format(t.kind)
            if i + 1 < g.len {
                self.write(",")
            }
        }
        self.write("]")
    }

    fn ident(self, id: &ast::IdentTypeDecl) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
        self.generics(id.generics)
    }

    fn namespace(self, ns: &ast::NamespaceTypeDecl) {
        for _, id in ns.idents {
            self.write(id.kind)
            self.write("::")
        }
        self.ident(ns.kind)
    }

    fn sptr(self, sptr: &ast::SptrTypeDecl) {
        self.write("&")
        self.format(sptr.elem.kind)
    }

    fn slc(self, slc: &ast::SlcTypeDecl) {
        self.write("[]")
        self.format(slc.elem.kind)
    }

    fn ptr(self, ptr: &ast::PtrTypeDecl) {
        self.write("*")
        if ptr.is_unsafe() {
            self.write("unsafe")
            ret
        }
        self.format(ptr.elem.kind)
    }

    fn arr(self, arr: &ast::ArrTypeDecl) {
        self.write("[")
        if arr.auto_sized() {
            self.write("...")
        } else {
            self.fmt.format_expr(arr.size)
        }
        self.write("]")
        self.format(arr.elem.kind)
    }

    fn map(self, map: &ast::MapTypeDecl) {
        self.write("[")
        self.format(map.key.kind)
        self.write(":")
        self.format(map.val.kind)
        self.write("]")
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::IdentTypeDecl:
            self.ident((&ast::IdentTypeDecl)(kind))
        | &ast::NamespaceTypeDecl:
            self.namespace((&ast::NamespaceTypeDecl)(kind))
        | &ast::SptrTypeDecl:
            self.sptr((&ast::SptrTypeDecl)(kind))
        | &ast::SlcTypeDecl:
            self.slc((&ast::SlcTypeDecl)(kind))
        | &ast::PtrTypeDecl:
            self.ptr((&ast::PtrTypeDecl)(kind))
        | &ast::ArrTypeDecl:
            self.arr((&ast::ArrTypeDecl)(kind))
        | &ast::MapTypeDecl:
            self.map((&ast::MapTypeDecl)(kind))
        }
    }
}

struct ExprFormatter {
    mut fmt: &Formatter
    mut buf: str
}

impl ExprFormatter {
    fn write(self, s: str) {
        self.fmt.buf += s
    }

    fn usexpr(self, u: &ast::UseExpr) {
        self.write("use ")
        self.format(u.expr.kind)
    }

    fn tuple(self, tup: &ast::TupleExpr) {
        for i, expr in tup.expr {
            self.format(expr.kind)
            if i + 1 < tup.expr.len {
                self.write(", ")
            }
        }
    }

    fn lit(self, l: &ast::LitExpr) {
        self.write(l.value)
    }

    fn unsafexpr(self, u: &ast::UnsafeExpr) {
        self.write("unsafe { ")
        self.format(u.expr)
        self.write(" }")
    }

    fn coexpr(self, c: &ast::CoExpr) {
        self.write("co ")
        self.format(c.expr.kind)
    }

    fn ident(self, id: &ast::IdentExpr) {
        if id.cpp_linked {
            self.write("cpp.")
        }
        self.write(id.ident)
    }

    fn unary(self, u: &ast::UnaryExpr) {
        self.write(u.op.kind)
        self.format(u.expr)
    }

    fn variadic(self, v: &ast::VariadicExpr) {
        self.format(v.expr)
        self.write("...")
    }

    fn cast(self, c: &ast::CastExpr) {
        self.write("(")
        self.fmt.format_type(c.kind)
        self.write(")")
        self.write("(")
        self.format(c.expr)
        self.write(")")
    }

    fn nselect(self, ns: &ast::NsSelectionExpr) {
        for _, s in ns.ns {
            self.write(s.kind)
            self.write("::")
        }
        self.write(ns.ident.kind)
    }

    fn sub_ident(self, si: &ast::SubIdentExpr) {
        self.format(si.expr)
        self.write(".")
        self.write(si.ident.kind)
    }

    fn binary(self, bin: &ast::BinopExpr) {
        self.format(bin.left)
        self.write(" ")
        self.write(bin.op.kind)
        self.write(" ")
        self.format(bin.right)
    }

    fn args(self, &args: []&ast::Expr) {
        for i, arg in args {
            self.format(arg.kind)
            if i + 1 < args.len {
                self.write(", ")
            }
        }
    }

    fn args_data(self, &args: []ast::ExprData) {
        for i, arg in args {
            self.format(arg)
            if i + 1 < args.len {
                self.write(", ")
            }
        }
    }

    fn fn_call(self, f: &ast::FnCallExpr) {
        self.format(f.expr.kind)
        let tf = TypeFormatter{
            fmt: self.fmt,
        }
        tf.generics(f.generics)
        self.write(tf.buf)
        self.write("(")
        self.args(f.args)
        self.write(")")
        if f.ignored() {
            self.write("!")
        } else if f.exception != nil {
            // SCOPE
        }
    }

    fn field_expr_pair(self, pair: &ast::FieldExprPair) {
        if pair.is_targeted() {
            self.write(pair.field.kind)
            self.write(": ")
        }
        self.format(pair.expr)
    }

    fn struct_lit(self, lit: &ast::StructLit) {
        self.fmt.format_type(lit.kind)
        if lit.exprs.len == 0 {
            self.write("{}")
            ret
        }
        self.write("{\n")
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.write(self.fmt.indent)
            self.format(expr)
            self.write(",\n")
        }
        self.fmt.done_indent()
        self.write("}")
    }

    fn brace_lit(self, lit: &ast::BraceLit) {
        self.write("{\n")
        self.fmt.add_indent()
        for _, expr in lit.exprs {
            self.write(self.fmt.indent)
            self.format(expr)
            self.write(",\n")
        }
        self.fmt.done_indent()
        self.write("}")
    }

    fn key_val_pair(self, pair: &ast::KeyValPair) {
        self.format(pair.key)
        self.write(": ")
        self.format(pair.val)
    }

    fn slice(self, s: &ast::SliceExpr) {
        self.write("[")
        self.args_data(s.elems)
        self.write("]")
    }

    fn indexing(self, i: &ast::IndexingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.index)
        self.write("]")
    }

    fn slicing(self, i: &ast::SlicingExpr) {
        self.format(i.expr)
        self.write("[")
        self.format(i.start)
        self.write(":")
        self.format(i.to)
        self.write("]")
    }

    fn ternary(self, t: &ast::TernaryExpr) {
        self.write("if ")
        self.format(t.condition)
        self.write(" { ")
        self.format(t.true_expr)
        self.write(" } else { ")
        self.format(t.false_expr)
        self.write(" }")
    }

    fn format(self, &kind: any) {
        match type kind {
        | &ast::Expr:
            let expr = (&ast::Expr)(kind)
            self.format(expr.kind)
        | &ast::IdentExpr:
            self.ident((&ast::IdentExpr)(kind))
        | &ast::UseExpr:
            self.usexpr((&ast::UseExpr)(kind))
        | &ast::TupleExpr:
            self.tuple((&ast::TupleExpr)(kind))
        | &ast::LitExpr:
            self.lit((&ast::LitExpr)(kind))
        | &ast::UnsafeExpr:
            self.unsafexpr((&ast::UnsafeExpr)(kind))
        | &ast::CoExpr:
            self.coexpr((&ast::CoExpr)(kind))
        | &ast::UnaryExpr:
            self.unary((&ast::UnaryExpr)(kind))
        | &ast::VariadicExpr:
            self.variadic((&ast::VariadicExpr)(kind))
        | &ast::CastExpr:
            self.cast((&ast::CastExpr)(kind))
        | &ast::NsSelectionExpr:
            self.nselect((&ast::NsSelectionExpr)(kind))
        | &ast::SubIdentExpr:
            self.sub_ident((&ast::SubIdentExpr)(kind))
        | &ast::BinopExpr:
            self.binary((&ast::BinopExpr)(kind))
        | &ast::FnCallExpr:
            self.fn_call((&ast::FnCallExpr)(kind))
        | &ast::FieldExprPair:
            self.field_expr_pair((&ast::FieldExprPair)(kind))
        | &ast::StructLit:
            self.struct_lit((&ast::StructLit)(kind))
        | &ast::BraceLit:
            self.brace_lit((&ast::BraceLit)(kind))
        | &ast::KeyValPair:
            self.key_val_pair((&ast::KeyValPair)(kind))
        | &ast::SliceExpr:
            self.slice((&ast::SliceExpr)(kind))
        | &ast::IndexingExpr:
            self.indexing((&ast::IndexingExpr)(kind))
        | &ast::SlicingExpr:
            self.slicing((&ast::SlicingExpr)(kind))
        | &ast::TernaryExpr:
            self.ternary((&ast::TernaryExpr)(kind))
        }
    }
}

// Returns maximum length of field identifiers.
// Length is calucated with public, mutable and identifier length, not including type.
// Returns length for private, private mut, public, public mut fields.
fn max_field_len(&fields: []&ast::FieldDecl): (p: int, pm: int, pb: int, pbm: int) {
    for _, f in fields {
        let n = f.ident.len
        match {
        | f.mutable:
            if f.public && n > pbm {
                pbm = n
            } else if !f.public && n > pm {
                pm = n
            }
        | f.public:
            if n > pb {
                pb = n
            }
        |:
            if n > p {
                p = n
            }
        }
    }
    ret
}
