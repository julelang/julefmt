// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::lex::{
    Token,
    TokenId,
}

struct comment {
    row: int
    col: int
    txt: str
}

struct commentMap {
    buf: []&comment
}

impl commentMap {
    static fn build(mut &tokens: []&Token): commentMap {
        let mut cm = commentMap{
            buf: make([]&comment, 0, 1 << 8),
        }
        let mut i = 0
        for i < tokens.len {
            let token = tokens[i]
            if token.Id != TokenId.Comment {
                i++
                continue
            }
            cm.buf = append(cm.buf, &comment{
                row: token.Row,
                col: token.Column,
                txt: token.Kind,
            })
            _ = copy(tokens[i:], tokens[i+1:])
            tokens = tokens[:tokens.len-1]
        }
        ret cm
    }

    fn first(mut self, row: int): &comment {
        if self.buf.len == 0 {
            ret nil
        }
        let mut c = self.buf[0]
        if row != -1 && c.row > row {
            ret nil
        }
        ret c
    }

    fn dropFirst(mut self) {
        self.buf = self.buf[1:]
    }

    fn pop(mut self, row: int): &comment {
        if self.buf.len == 0 {
            ret nil
        }
        let mut c = self.buf[0]
        if c.row > row {
            ret nil
        }
        self.dropFirst()
        ret c
    }

    fn find(mut self, row: int): &comment {
        if self.buf.len == 0 {
            ret nil
        }
        let mut c = self.buf[0]
        if c.row > row {
            ret nil
        }
        ret c
    }
}