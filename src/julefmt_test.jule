// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/testing"

struct formatTest {
	data: str
	out:  str
}

let formatTests = []formatTest([
	{
		data: `	const 	(
kind	: str       = types :: F32
	max				 = types	::MaxF32
			min 		= types::MinF32
	smallestNonzero =	 types::		SmallestNonzeroF32
	)	`,
		out: `const (
	kind: str       = types::F32
	max             = types::MaxF32
	min             = types::MinF32
	smallestNonzero = types::SmallestNonzeroF32
)`,
	},
	{
		data: `const(
	Sunaday				: Weekday	 =						iota
	Monday
					Tuesday
				Wednesdaysssssssssss
						Thursday
Friday
Saturday)`,
		out: `const (
	Sunaday: Weekday = iota
	Monday
	Tuesday
	Wednesdaysssssssssss
	Thursday
	Friday
	Saturday
)`,
	},
	{
		data: `const (
	Sunday: Weekday = iota // foo
     	Monaday	:    int            // foo
	Tuesaday	:   	bool    = iota // foo
         	Wednesday	:  bool           // foo
foo        // foo
Thuradayaaaaaaaaa          = iota// foo
aaFriaday:			 bool    = iota// foo
Saturday:          int     = iota // foo
foo                      // foo
foo:         		       str            // foo
	 z:                 int     = iota 				// foo
 foa:bool= iota// foo
)`,
		out: `const (
	Sunday:            Weekday = iota // foo
	Monaday:           int            // foo
	Tuesaday:          bool    = iota // foo
	Wednesday:         bool           // foo
	foo                               // foo
	Thuradayaaaaaaaaa          = iota // foo
	aaFriaday:         bool    = iota // foo
	Saturday:          int     = iota // foo
	foo                               // foo
	foo:               str            // foo
	z:                 int     = iota // foo
	foa:               bool    = iota // foo
)`,
	},
	{
		data: `const (
	Sunday: Weekday=iota // foo
	Monaday: int     // foo
	Tuesaday: bool = iota // foo
	Wednesday: bool
				foo          // foo
	Thuradayaaaaaaaaa       = iota // foo
	aaFriaday:   			      bool=iota// foo
	Saturday:          int  				= 			iota // foo
			foo
	foo: str         				// foo
	z:   	int  =iota 				// foo
			foa							:bool = iota 				// foo
			)`,
		out: `const (
	Sunday:    Weekday = iota // foo
	Monaday:   int            // foo
	Tuesaday:  bool    = iota // foo
	Wednesday: bool
	foo                            // foo
	Thuradayaaaaaaaaa       = iota // foo
	aaFriaday:         bool = iota // foo
	Saturday:          int  = iota // foo
	foo
	foo: str         // foo
	z:   int  = iota // foo
	foa: bool = iota // foo
)`,
	},
	{
		data: `const (
Layout            = "01/02 03:04:05PM '06 -0700" // The reference time, in numerical order.
ANSIC       	      = "Mon Jan _2 15:04:05 2006"
	UnixDate          = "Mon Jan _2 15:04:05 MST 2006"			
RubyDate          = "Mon Jan 02 15:04:05 -0700 2006"
RFC822  	    =			 "02 Jan 06 15:04 MST"
RFC822Z   ="02 Jan 06 15:04 -0700" // RFC822 with numeric zone
	RFC850            ="Monday, 02-Jan-06 15:04:05 MST"
	RFC1123:fn(	bool		) ="Mon, 02 Jan 2006 15:04:05 MST"
   RFC1123Z="Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
	RFC3339    ="2006-01-02T15:04:05Z07:00"
		RFC3339Nano       ="2006-01-02T15:04:05.999999999Z07:00"
	Kitchen           ="3:04PM"

Stamp="Jan _2 15:04:05"
StampMilli     ="Jan _2 15:04:05.000"
StampMicro:int="Jan _2 15:04:05.000000"
StampNano	="Jan _2 15:04:05.000000000"
DateTime 	="2006-01-02 15:04:05"
DateOnly 	="2006-01-02"
TimeOnly 	="15:04:05"
)`,
		out: `const (
	Layout            = "01/02 03:04:05PM '06 -0700" // The reference time, in numerical order.
	ANSIC             = "Mon Jan _2 15:04:05 2006"
	UnixDate          = "Mon Jan _2 15:04:05 MST 2006"
	RubyDate          = "Mon Jan 02 15:04:05 -0700 2006"
	RFC822            = "02 Jan 06 15:04 MST"
	RFC822Z           = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
	RFC850            = "Monday, 02-Jan-06 15:04:05 MST"
	RFC1123: fn(bool) = "Mon, 02 Jan 2006 15:04:05 MST"
	RFC1123Z          = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
	RFC3339           = "2006-01-02T15:04:05Z07:00"
	RFC3339Nano       = "2006-01-02T15:04:05.999999999Z07:00"
	Kitchen           = "3:04PM"

	Stamp           = "Jan _2 15:04:05"
	StampMilli      = "Jan _2 15:04:05.000"
	StampMicro: int = "Jan _2 15:04:05.000000"
	StampNano       = "Jan _2 15:04:05.000000000"
	DateTime        = "2006-01-02 15:04:05"
	DateOnly        = "2006-01-02"
	TimeOnly        = "15:04:05"
)`,
	},
	{
		data: `const (
_              = iota
	stdLongMonth   = iota + stdNeedDate  // "January"
	stdMonth                             // "Jan"
					stdNumMonth                          // "1"
			stdZeroMonth                         // "01"
				stdLongWeekDay                       // "Monday"
					stdWeekDay                           // "Mon"
	stdDay                               // "2"
								stdUnderDay                          // "_2"
					stdZeroDay                           // "02"
					stdUnderYearDay= iota + stdNeedYday  // "__2"
					stdZeroYearDay                       // "002"
		stdHour        = iota + stdNeedClock // "15"
					stdHour12                            // "3"
stdZeroHour12                        // "03"
					stdMinute                            // "4"
					stdZeroMinute                        // "04"
	stdSecond                            // "5"
	stdZeroSecond                        // "05"
	stdLongYear    = iota+stdNeedDate  // "2006"
	stdYear                              // "06"
	stdPM          = iota+stdNeedClock // "PM"
	     		stdpm                                // "pm"
stdTZ          = iota                // "MST"
	stdISO8601TZ       // "Z0700"  // prints Z for UTC
	stdISO8601SecondsTZ                            // "Z070000"
	stdISO8601ShortTZ       // "Z07"
	stdISO8601ColonTZ                              // "Z07:00" // prints Z for UTC
	stdISO8601ColonSecondsTZ                       // "Z07:00:00"
			stdNumTZ                                       // "-0700"  // always numeric
				stdNumSecondsTz                                // "-070000"
	stdNumShortTZ                                  // "-07"    // always numeric
	stdNumColonTZ                                  // "-07:00" // always numeric
			stdNumColonSecondsTZ       // "-07:00:00"
	stdFracSecond0                                 // ".0", ".00", ... , trailing zeros included
					stdFracSecond9      // ".9", ".99", ..., trailing zeros omitted

		stdNeedDate= 				1 		<<8            // need month, day, year
stdNeedYday  	  = 				1 <<9            // need yday
stdNeedClock  = 				1<<10           // need hour, minute, second
				stdArgShift       = 				16                // extra argument in high bits, above low stdArgShift
stdSeparatorShift= 			28                // extra argument in high 4 bits for fractional second separators
stdMask           =1<<stdArgShift-1// mask out argument
)`,
		out: `const (
	_                        = iota
	stdLongMonth             = iota + stdNeedDate  // "January"
	stdMonth                                       // "Jan"
	stdNumMonth                                    // "1"
	stdZeroMonth                                   // "01"
	stdLongWeekDay                                 // "Monday"
	stdWeekDay                                     // "Mon"
	stdDay                                         // "2"
	stdUnderDay                                    // "_2"
	stdZeroDay                                     // "02"
	stdUnderYearDay          = iota + stdNeedYday  // "__2"
	stdZeroYearDay                                 // "002"
	stdHour                  = iota + stdNeedClock // "15"
	stdHour12                                      // "3"
	stdZeroHour12                                  // "03"
	stdMinute                                      // "4"
	stdZeroMinute                                  // "04"
	stdSecond                                      // "5"
	stdZeroSecond                                  // "05"
	stdLongYear              = iota + stdNeedDate  // "2006"
	stdYear                                        // "06"
	stdPM                    = iota + stdNeedClock // "PM"
	stdpm                                          // "pm"
	stdTZ                    = iota                // "MST"
	stdISO8601TZ                                   // "Z0700"  // prints Z for UTC
	stdISO8601SecondsTZ                            // "Z070000"
	stdISO8601ShortTZ                              // "Z07"
	stdISO8601ColonTZ                              // "Z07:00" // prints Z for UTC
	stdISO8601ColonSecondsTZ                       // "Z07:00:00"
	stdNumTZ                                       // "-0700"  // always numeric
	stdNumSecondsTz                                // "-070000"
	stdNumShortTZ                                  // "-07"    // always numeric
	stdNumColonTZ                                  // "-07:00" // always numeric
	stdNumColonSecondsTZ                           // "-07:00:00"
	stdFracSecond0                                 // ".0", ".00", ... , trailing zeros included
	stdFracSecond9                                 // ".9", ".99", ..., trailing zeros omitted

	stdNeedDate       = 1 << 8             // need month, day, year
	stdNeedYday       = 1 << 9             // need yday
	stdNeedClock      = 1 << 10            // need hour, minute, second
	stdArgShift       = 16                 // extra argument in high bits, above low stdArgShift
	stdSeparatorShift = 28                 // extra argument in high 4 bits for fractional second separators
	stdMask           = 1<<stdArgShift - 1 // mask out argument
)`,
	},
	{
		data: `struct Foo{
    Foo:int"json:\"foo\""// foo
    Fooooo:bool"json:\"bar\""// foo
    F:MyType"json:\"baz\""// foo
    Foo:int"json:\"buz\""// foo
}`,
		out: `struct Foo {
	Foo:    int    "json:\"foo\"" // foo
	Fooooo: bool   "json:\"bar\"" // foo
	F:      MyType "json:\"baz\"" // foo
	Foo:    int    "json:\"buz\"" // foo
}`,
	},
	{
		data: `fn foo() {
if foo && bar && baz {
	}

	}`,
		out: `fn foo() {
	if foo && bar && baz {
	}
}`,
	},
	{
		data: `fn foo() {
if foo &&
bar &&
baz {}

	}`,
		out: `fn foo() {
	if foo &&
		bar &&
		baz {
	}
}`,
	},
	{
		data: `fn foo() {
if self.r == eof ||
self.r != ' ' &&
self.r==
"hello"==
'a' &&
self.r != '\t' &&
self.r != '\v' ||
self.r != '\r' ||
self.r != '\n' &&
self.r == 20 &&
self.r == 20 {
continue}

	}`,
		out: `fn foo() {
	if self.r == eof ||
		self.r != ' ' &&
			self.r ==
				"hello" ==
				'a' &&
			self.r != '\t' &&
			self.r != '\v' ||
		self.r != '\r' ||
		self.r != '\n' &&
			self.r == 20 &&
			self.r == 20 {
		continue
	}
}`,
	},
	{
		data: `fn foo() {
if self.r &&
self.r ==
"hello" &&
'a' ||
self.r != '\t' {
continue
	}}`,
		out: `fn foo() {
	if self.r &&
		self.r ==
			"hello" &&
		'a' ||
		self.r != '\t' {
		continue
	}
}`,
	},
	{
		data: `fn foo() {
foo.Foo().
Bar(
"foo", "bar").
Baz().BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().
		Bar(
			"foo", "bar").
		Baz().BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.Foo().Bar(
"foo","bar").Baz().BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().Bar(
		"foo", "bar").Baz().BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.Foo().Bar(
"foo",
"bar").Baz().BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().Bar(
		"foo",
		"bar").Baz().BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.Foo().Bar("foo",
"bar").Baz().BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().Bar("foo",
		"bar").Baz().BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.Foo().Bar("foo",
"bar").
Baz().
BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().Bar("foo",
		"bar").
		Baz().
		BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.Foo().Bar("foo","bar").
Baz().
BarBaz()
	}`,
		out: `fn foo() {
	foo.Foo().Bar("foo", "bar").
		Baz().
		BarBaz()
}`,
	},
	{
		data: `fn foo() {
foo.
Bar().
Baz(
"foo",
"bar",
"baz") else {
println("error handling...")
}}`,
		out: `fn foo() {
	foo.
		Bar().
		Baz(
			"foo",
			"bar",
			"baz") else {
		println("error handling...")
	}
}`,
	},
	{
		data: `fn main() {
	data 			= append ( data, 0) // foo
foo(	)else{} 						// bar
}`,
		out: `fn main() {
	data = append(data, 0) // foo
	foo() else {} // bar
}`,
	},
	{
		data: `fn 	main(
		) {data= 		append(data, 0) // foo
bar()// bar
baz()// baz
	foo()else{} // bar
}`,
		out: `fn main() {
	data = append(data, 0) // foo
	bar()                  // bar
	baz()                  // baz
	foo() else {} // bar
}`,
	},
	{
		data: `fn main() {
	// hello world
	_ = [
		// foo
/*ff*/				/*ff*/ fn(){
			// foo
			// Hello World /**/ /*foo*/
},		foo,
		/* foo*/ foo{},
	]}`,
		out: `fn main() {
	// hello world
	_ = [
		// foo
		/*ff*/ /*ff*/ fn() {
			// foo
			// Hello World /**/ /*foo*/
		},
		foo,
		/* foo*/ foo{},
	]
}`,
	},
	{
		data: `fn main() {
	// hello world
	_ = [

		// foo
/*ff*/				/*ff*/ fn(){
			// foo
			// Hello World /**/ /*foo*/
},		foo,
		/* foo*/ foo{},
	]}`,
		out: `fn main() {
	// hello world
	_ = [

		// foo
		/*ff*/ /*ff*/ fn() {
			// foo
			// Hello World /**/ /*foo*/
		},
		foo,
		/* foo*/ foo{},
	]
}`,
	},
	{
		data: `fn main() {
	let encodeCases: []encodeTest = [
		{[1, 2, 3, 4], [1, 2, 3, 4]},
		{[0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff],
			[0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff],
		},
		{['a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1],
			['a', 'b', 0xd7ff, 0xfffd, 0xfffd, 0xe000, 0xfffd, 0xfffd],
		},
	]}`,
		out: `fn main() {
	let encodeCases: []encodeTest = [
		{[1, 2, 3, 4], [1, 2, 3, 4]},
		{[0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff],
			[0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff],
		},
		{['a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1],
			['a', 'b', 0xd7ff, 0xfffd, 0xfffd, 0xe000, 0xfffd, 0xfffd],
		},
	]
}`,
	},
	{
		data: `fn main() {
		_ = {
		Name: "RFC4180test",
		Input: ` + "`" + `§#field1,§field2,§field3
¶§"aaa",§"bb
b",§"ccc"
¶§"a,a",§"b""bb",§"ccc"
¶§zzz,§yyy,§xxx
			abskbf` + "`" + `,
		foo: 0,
	}}`,
		out: `fn main() {
	_ = {
		Name: "RFC4180test",
		Input: ` + "`" + `§#field1,§field2,§field3
¶§"aaa",§"bb
b",§"ccc"
¶§"a,a",§"b""bb",§"ccc"
¶§zzz,§yyy,§xxx
			abskbf` + "`" + `,
		foo: 0,
	}
}`,
	},
	{
		data: `fn main() {
		let leftCheats: []leftCheat = [
		// Leading digits of 1/2^i = 5^i.

		// 5^23 is not an exact 64-bit floating point number,
		// so have to use bc for the math.
		// Go up to 60 to be large enough for 32bit and 64bit platforms.
		/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
		*/

		{0, ""},
	]
		}`,
		out: `fn main() {
	let leftCheats: []leftCheat = [
		// Leading digits of 1/2^i = 5^i.

		// 5^23 is not an exact 64-bit floating point number,
		// so have to use bc for the math.
		// Go up to 60 to be large enough for 32bit and 64bit platforms.
		/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
		*/

		{0, ""},
	]
}`,
	},
	{
		data: `fn main() {
		let leftCheats: []leftCheat = [
		// Leading digits of 1/2^i = 5^i.

		// 5^23 is not an exact 64-bit floating point number,
		// so have to use bc for the math.
		// Go up to 60 to be large enough for 32bit and 64bit platforms.
		/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
		*/
		{0, ""},
	]
		}`,
		out: `fn main() {
	let leftCheats: []leftCheat = [
		// Leading digits of 1/2^i = 5^i.

		// 5^23 is not an exact 64-bit floating point number,
		// so have to use bc for the math.
		// Go up to 60 to be large enough for 32bit and 64bit platforms.
		/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
		*/
		{0, ""},
	]
}`,
	},
	{
		data: `let surrogateCases: []surrogateTest = [

		// from https://en.wikipedia.org/wiki/UTF-16

		{'\u007A', false},     // LATIN SMALL LETTER Z
		{'\u6C34', false},     // CJK UNIFIED IDEOGRAPH-6C34 (water)
			{'\uFEFF', false},     // Byte Order Mark
		{'\U00010000', false}, // LINEAR B SYLLABLE B008 A (first non-BMP code point)
				{'\U0001D11E', false}, // MUSICAL SYMBOL G CLEF
		{'\U0010FFFD', false}, // PRIVATE USE CHARACTER-10FFFD (last Unicode code point)
			{0xd7ff, false},       // surr1-1


// foo
// bar
		// baz


		{0xd800, true},  // surr1
		{0xdc00, true},  // surr2
		{0xe000, false}, // surr3
		{0xdfff, true},  // surr3-1
	]`,
		out: `let surrogateCases: []surrogateTest = [

	// from https://en.wikipedia.org/wiki/UTF-16

	{'\u007A', false},     // LATIN SMALL LETTER Z
	{'\u6C34', false},     // CJK UNIFIED IDEOGRAPH-6C34 (water)
	{'\uFEFF', false},     // Byte Order Mark
	{'\U00010000', false}, // LINEAR B SYLLABLE B008 A (first non-BMP code point)
	{'\U0001D11E', false}, // MUSICAL SYMBOL G CLEF
	{'\U0010FFFD', false}, // PRIVATE USE CHARACTER-10FFFD (last Unicode code point)
	{0xd7ff, false},       // surr1-1

	// foo
	// bar
	// baz

	{0xd800, true},  // surr1
	{0xdc00, true},  // surr2
	{0xe000, false}, // surr3
	{0xdfff, true},  // surr3-1
]`,
	},
	{
		data: `
		
		// Information about the first byte in a UTF-8 sequence.
let first: [256]byte = [
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
		//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
]
		
		`,
		out: `// Information about the first byte in a UTF-8 sequence.
let first: [256]byte = [
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
]`,
	},
	{
		data: `let x={1,100,
"933262154439441526816992388562667004907159682643816214685929" +
"638952175999932299156089414639761565182862536979208272237582" + // foo
"51185210916864000000000000000000000000", // 100!
}`,
		out: `let x = {1, 100,
	"933262154439441526816992388562667004907159682643816214685929" +
		"638952175999932299156089414639761565182862536979208272237582" + // foo
		"51185210916864000000000000000000000000", // 100!
}`,
	},
])

#test
fn testFormat(t: &testing::T) {
	for i, c in formatTests {
		out := format("<test-input>", []byte(c.data))
		if str(out) != c.out {
			t.Errorf("#{} failed", i)
		}
	}
}