// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env for std::env
use std::fs::{Directory, File}
use path for std::fs::path
use process for std::process
use std::jule::build::{EXT}
use lex for std::jule::lex
use parser for std::jule::parser
use sema for std::jule::sema::{
    SemaFlag,
}
use strings for std::strings

fn format_file(path: str) {
    let mut file = lex::new_file_set(path)
    file.fill(File.read(path) else {
        outln("error: file could not read: " + path)
        ret
    })
    let mut errors = lex::lex(file, lex::LexMode.Comment)
    if errors.len > 0 {
        outln("error: file could not formatted, have error(s): " + path)
        ret
    }

    let mut cm = CommentMap.build(file.tokens)
    let mut finfo = parser::parse_file(file)
    if finfo.errors.len > 0 {
        outln("error: file could not formatted, have error(s): " + path)
        ret
    }

    let mut f = finfo.ast
    let fmt = Formatter.new()
    let buf = fmt.format(f, cm)
    let fpath = f.file.path
    File.write(fpath, []byte(buf), 0o660) else {
        outln("error: could not write to file: " + fpath)
        ret
    }
}

fn parse_package(path: str) {
    let mut dirents = Directory.read(path) else {
        outln("error: connot read package directory: " + path)
        ret
    }
    for _, dirent in dirents {
        // Skip directories, and non-jule files.
        if dirent.stat.is_dir() || !strings::has_suffix(dirent.name, EXT) {
            continue
        }

        let filepath = path::join(path, dirent.name)
        format_file(filepath)
    }
}

fn main() {
    let args = env::args()
    if args.len == 1 {
        ret
    }
    parse_package(args[1])
}