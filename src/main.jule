// Copyright 2024 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/flag"
use "std/io"
use "std/jule"
use "std/jule/parser"
use "std/jule/token"
use "std/os"
use "std/os/filepath"
use "std/strings"

let mut _W = new(bool, false) // Flag -w

async fn writeError(message: str) {
	os::Stderr().WriteStr(message).await!
	os::Stderr().WriteStr("\n").await!
}

// Prints formatted data to relevant file.
async fn printFormat(path: str, data: []byte) {
	if data == nil {
		ret
	}
	if *_W {
		os::WriteFile(path, data, 0o660).await else {
			writeError("error: could not write to file: " + path).await
			ret
		}
	} else {
		os::Stdout().Write(data).await else {
			writeError("error: could not write stdout").await
			ret
		}
	}
}

// Formats data with path, and returns result.
// If result is nil, we have an error(s).
async fn format(path: str, mut data: []byte): []byte {
	mut file := token::FileSet.New(path)
	unsafe { file.FillMut(data) }
	mut errors := token::ScanAll(file, token::Comments)
	if len(errors) > 0 {
		writeError("error: file could not formatted, have error(s): " + path).await
		ret nil
	}

	mut cm := commentMap.build(&file.Tokens)
	mut finfo := parser::ParseFile(file)
	if len(finfo.Errors) > 0 {
		writeError("error: file could not formatted, have error(s): " + path).await
		ret nil
	}

	fmt := formatter.new()
	ret fmt.format(finfo.AST, cm)
}

async fn formatFile(path: str) {
	mut ctx := os::ReadFile(path).await else {
		writeError("error: file could not read: " + path).await
		ret
	}
	data := format(path, ctx).await
	printFormat(path, data).await
}

async fn parsePackage(path: str) {
	mut dirents := os::ReadDir(path) else {
		writeError("error: connot read package directory: " + path).await
		ret
	}
	for _, dirent in dirents {
		// Skip directories, and non-jule files.
		if dirent.Stat.IsDir() || !strings::HasSuffix(dirent.Name, jule::Ext) {
			continue
		}
		filepath := filepath::Join(path, dirent.Name)
		formatFile(filepath).await
	}
}

async fn parse(path: str) {
	stat := os::Stat(path) else {
		writeError("error: connot read path: " + path).await
		ret
	}
	m := stat.Mode()
	match {
	| m.IsDir():
		parsePackage(path).await
		ret
	| m.IsRegular():
		if strings::HasSuffix(path, jule::Ext) {
			formatFile(path).await
			ret
		}
	}
	writeError("error: path is not supported: " + path).await
}

async fn cliMode() {
	if *_W {
		writeError("error: -w argument cannot used with stdout mode").await
		ret
	}
	mut i := 0
	mut buf := make([]byte, 1024)
	for {
		n := os::Stdin().Read(buf[i:]).await else {
			writeError("error: could not read from stdin").await
			ret
		}
		if n == io::EOF {
			break
		}
		i += n
		if i >= len(buf) {
			// Need more space, so grow.
			mut newBuf := make([]byte, len(buf)*2)
			copy(newBuf, buf)
			buf = newBuf
		}
	}
	buf = buf[:i]
	printFormat("<stdin>", format("<stdin>", buf).await).await
}

async fn main() {
	mut args := os::Args()
	args = args[1:] // Skip program path.
	mut flag := flag::FlagSet.New()
	flag.AddVar(_W, "write", 'w', "write result to (source) file instead of stdout")
	args = flag.Parse(args)!
	if len(args) == 0 {
		cliMode().await
	} else {
		parse(args[0]).await
	}
}